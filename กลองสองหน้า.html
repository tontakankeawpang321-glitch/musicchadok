<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>‡∏Å‡∏•‡∏≠‡∏á‡∏™‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤ - ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏°‡∏à‡∏£‡∏¥‡∏á</title>
    <style>
        /* ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô */
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            background: radial-gradient(circle, #2c2c2c 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            font-family: 'Sarabun', sans-serif;
            touch-action: none;
        }

        /* ‡πÅ‡∏ú‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô */
        .controls {
            position: absolute;
            top: 20px;
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            z-index: 100;
        }

        .btn {
            background: #444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn.recording {
            background: #ff4444;
            animation: pulse 1s infinite;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≠‡∏á */
        .drum-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 90vw;
            height: 60vh;
            position: relative;
        }

        /* ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡∏≠‡∏á (‡∏ö‡∏≠‡∏î‡∏µ‡πâ‡πÑ‡∏°‡πâ) */
        .drum-body {
            width: 80%;
            height: 100%;
            background: linear-gradient(90deg, #5d4037 0%, #8d6e63 20%, #a1887f 50%, #8d6e63 80%, #5d4037 100%);
            border-radius: 20px;
            position: absolute;
            z-index: 1;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8) inset, 0 20px 50px rgba(0,0,0,0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* ‡∏•‡∏≤‡∏¢‡πÑ‡∏°‡πâ */
        .wood-texture {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.3;
            background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, #3e2723 10px, #3e2723 12px);
            border-radius: 20px;
            pointer-events: none;
        }

        /* ‡∏´‡∏ô‡∏±‡∏á‡∏Å‡∏•‡∏≠‡∏á (Head) */
        .drum-head {
            position: relative;
            z-index: 2;
            background: radial-gradient(circle at 30% 30%, #fff3e0, #d7ccc8, #a1887f);
            border-radius: 50%;
            box-shadow: 
                inset 0 0 20px rgba(0,0,0,0.5),
                0 0 0 8px #3e2723, /* ‡∏Ç‡∏≠‡∏ö‡πÑ‡∏°‡πâ */
                0 0 0 12px #5d4037, /* ‡∏Ç‡∏≠‡∏ö‡πÄ‡∏ä‡∏∑‡∏≠‡∏Å */
                5px 0 15px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: transform 0.05s;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            overflow: hidden; /* ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ ripple ‡πÑ‡∏°‡πà‡∏•‡πâ‡∏ô */
        }

        .drum-head:active, .drum-head.active {
            transform: scale(0.96);
            background: radial-gradient(circle at 30% 30%, #ffe0b2, #d7ccc8, #8d6e63);
        }

        /* ‡πÇ‡∏ã‡∏ô‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏û‡∏¥‡πÄ‡∏®‡∏© */
        .hit-zone-indicator {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 60%, rgba(255,200,100,0.2) 61%);
            opacity: 0.5;
        }

        /* ‡∏´‡∏ô‡πâ‡∏≤‡∏ã‡πâ‡∏≤‡∏¢ (‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏∏‡πâ‡∏°/‡πÉ‡∏´‡∏ç‡πà) */
        .head-left {
            width: 35vh;
            height: 35vh;
            max-width: 45vw;
            max-height: 45vw;
            margin-left: -5%;
        }

        /* ‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏ß‡∏≤ (‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏´‡∏•‡∏°/‡πÄ‡∏•‡πá‡∏Å) */
        .head-right {
            width: 30vh;
            height: 30vh;
            max-width: 40vw;
            max-height: 40vw;
            margin-right: -5%;
        }

        /* ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÇ‡∏ô‡πâ‡∏ï */
        .note-label {
            position: absolute;
            color: rgba(62, 39, 35, 0.8);
            font-weight: bold;
            font-size: 2rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 1px 1px 0px rgba(255,255,255,0.3);
            z-index: 10;
        }
        
        .show-notes .note-label {
            opacity: 1;
        }

        /* Visual Feedback effect */
        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            transform: scale(0);
            animation: ripple-anim 0.4s linear;
            pointer-events: none;
        }

        @keyframes ripple-anim {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); }
        }

        .footer-text {
            position: absolute;
            bottom: 10px;
            color: #666;
            font-size: 12px;
            text-align: center;
        }

    </style>
</head>
<body>

    <div class="controls">
        <button class="btn" id="btnNotes">üéµ ‡πÇ‡∏ô‡πâ‡∏ï</button>
        <button class="btn" id="btnRecord">üî¥ ‡∏≠‡∏±‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á</button>
        <button class="btn" id="btnStop" disabled>‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
        <button class="btn" id="btnPlay" disabled>‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô</button>
        <button class="btn" id="btnDownload" disabled>‚¨áÔ∏è ‡πÇ‡∏´‡∏•‡∏î</button>
    </div>

    <div class="drum-container" id="drumContainer">
        <div class="drum-body">
            <div class="wood-texture"></div>
            <div style="width:100%; height: 2px; background:#3e2723; position:absolute; top:20%;"></div>
            <div style="width:100%; height: 2px; background:#3e2723; position:absolute; bottom:20%;"></div>
            <div style="width:100%; height: 2px; background:#3e2723; position:absolute; top:50%;"></div>
        </div>

        <!-- ‡∏´‡∏ô‡πâ‡∏≤‡∏ã‡πâ‡∏≤‡∏¢ (‡∏ó‡∏∏‡πâ‡∏°) -->
        <div class="drum-head head-left" id="padLeft">
            <div class="hit-zone-indicator"></div>
            <span class="note-label">‡∏ï‡∏∏‡πâ‡∏°/‡∏Ç‡∏≠‡∏ö</span>
        </div>

        <!-- ‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏ß‡∏≤ (‡πÅ‡∏´‡∏•‡∏°) -->
        <div class="drum-head head-right" id="padRight">
            <div class="hit-zone-indicator"></div>
            <span class="note-label">‡∏ï‡∏∂‡∏á/‡πÅ‡∏õ‡πä‡∏∞</span>
        </div>
    </div>

    <div class="footer-text">
        ‡∏ï‡∏µ‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á: ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö | ‡∏ï‡∏µ‡∏Ç‡∏≠‡∏ö: ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÇ‡∏•‡∏´‡∏∞/Slap<br>
        ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Multi-touch ‡∏ï‡∏µ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ
    </div>

    <script>
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let masterGain;
        let limiter;
        let reverbNode;
        let reverbFilter;
        let dryGain;
        let wetGain;
        let dest;
        let mediaRecorder;
        let chunks = [];
        let recordedBlob;
        let audioURL;
        let playbackAudio = new Audio();

        function createReverbBuffer() {
            // Reverb ‡πÅ‡∏ö‡∏ö‡∏™‡∏±‡πâ‡∏ô‡∏°‡∏≤‡∏Å (Short Room) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡πÄ‡∏ö‡∏™‡∏ö‡∏ß‡∏°
            const duration = 0.4; // ‡∏•‡∏î‡∏•‡∏á‡∏≠‡∏µ‡∏Å‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 0.4 ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î
            const decay = 5.0;    // ‡∏´‡∏≤‡∏¢‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô
            const rate = audioCtx.sampleRate;
            const length = rate * duration;
            const impulse = audioCtx.createBuffer(2, length, rate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                const n = i / length;
                left[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
                right[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
            }
            return impulse;
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
                
                limiter = audioCtx.createDynamicsCompressor();
                limiter.threshold.value = -3;
                limiter.ratio.value = 12;
                limiter.attack.value = 0.002;

                masterGain = audioCtx.createGain();
                masterGain.gain.value = 1.0;

                reverbNode = audioCtx.createConvolver();
                reverbNode.buffer = createReverbBuffer();
                
                reverbFilter = audioCtx.createBiquadFilter();
                reverbFilter.type = 'lowpass';
                reverbFilter.frequency.value = 800; // ‡∏Å‡∏£‡∏≠‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏™‡∏π‡∏á‡∏≠‡∏≠‡∏Å ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡πÅ‡∏ï‡πà‡∏ö‡∏£‡∏£‡∏¢‡∏≤‡∏Å‡∏≤‡∏®‡∏ó‡∏∏‡πâ‡∏°‡πÜ

                wetGain = audioCtx.createGain();
                wetGain.gain.value = 0.3; // Reverb ‡∏ö‡∏≤‡∏á‡πÜ ‡∏û‡∏≠‡∏°‡∏µ‡∏°‡∏¥‡∏ï‡∏¥
                
                dryGain = audioCtx.createGain();
                dryGain.gain.value = 1.0;

                reverbNode.connect(reverbFilter);
                reverbFilter.connect(wetGain);
                
                wetGain.connect(masterGain);
                dryGain.connect(masterGain);
                
                masterGain.connect(limiter);
                limiter.connect(audioCtx.destination);

                dest = audioCtx.createMediaStreamDestination();
                masterGain.connect(dest);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- Sound Synthesis ---
        
        function playSound(type, zoneFactor) {
            initAudio();
            const t = audioCtx.currentTime;
            
            const hitGain = audioCtx.createGain();
            hitGain.connect(dryGain);
            hitGain.connect(reverbNode);
            hitGain.gain.setValueAtTime(1.0, t);

            if (type === 'left') { 
                // ‡∏ã‡πâ‡∏≤‡∏¢: ‡∏ó‡∏∏‡πâ‡∏° + ‡∏™‡∏±‡πâ‡∏ô (Deep Thud)
                
                if (zoneFactor < 0.6) { // === CENTER / ‡∏ï‡∏∏‡πâ‡∏° ===
                    // 1. Sub Bass (Deep & Short)
                    const oscSub = audioCtx.createOscillator();
                    const gainSub = audioCtx.createGain();
                    oscSub.frequency.setValueAtTime(60, t); // ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏•‡∏á (Deep) ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏µ‡πà 60Hz
                    oscSub.frequency.exponentialRampToValueAtTime(30, t + 0.2); // ‡∏•‡∏á‡∏•‡∏∂‡∏Å‡πÑ‡∏õ‡∏ñ‡∏∂‡∏á 30Hz
                    
                    gainSub.gain.setValueAtTime(1.5, t);
                    gainSub.gain.exponentialRampToValueAtTime(0.01, t + 0.15); // ‡∏™‡∏±‡πâ‡∏ô! (Short)

                    // 2. Impact (‡∏´‡∏±‡∏ß‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏´‡∏ô‡∏±‡∏Å‡πÜ)
                    const oscImpact = audioCtx.createOscillator();
                    const gainImpact = audioCtx.createGain();
                    oscImpact.type = 'square'; // Square ‡πÉ‡∏´‡πâ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏ó‡∏µ‡πà‡∏´‡∏ô‡∏≤‡∏Å‡∏ß‡πà‡∏≤ Sine
                    oscImpact.frequency.setValueAtTime(100, t); // ‡∏´‡∏±‡∏ß‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ï‡πà‡∏≥‡∏•‡∏á
                    oscImpact.frequency.exponentialRampToValueAtTime(40, t + 0.08);
                    
                    gainImpact.gain.setValueAtTime(1.0, t);
                    gainImpact.gain.exponentialRampToValueAtTime(0.01, t + 0.08); // ‡∏™‡∏±‡πâ‡∏ô‡∏°‡∏≤‡∏Å

                    oscSub.connect(gainSub).connect(hitGain);
                    oscImpact.connect(gainImpact).connect(hitGain);
                    
                    oscSub.start(t); oscSub.stop(t + 0.25);
                    oscImpact.start(t); oscImpact.stop(t + 0.1);

                } else { // === RIM / ‡∏Ç‡∏≠‡∏ö (Metallic but Heavy) ===
                    // ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ç‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏´‡∏ô‡∏±‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô ‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏∏‡πâ‡∏°
                    const carrier = audioCtx.createOscillator();
                    const modulator = audioCtx.createOscillator();
                    const modGain = audioCtx.createGain();
                    const carrierGain = audioCtx.createGain();

                    carrier.type = 'sine';
                    carrier.frequency.setValueAtTime(600, t); // ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡∏Ç‡∏≠‡∏ö‡∏•‡∏á‡πÉ‡∏´‡πâ‡∏´‡∏ô‡∏≤‡∏Ç‡∏∂‡πâ‡∏ô
                    
                    modulator.type = 'square';
                    modulator.frequency.value = 840;
                    
                    modGain.gain.setValueAtTime(800, t);
                    modGain.gain.exponentialRampToValueAtTime(1, t + 0.1);

                    carrierGain.gain.setValueAtTime(0.8, t);
                    carrierGain.gain.exponentialRampToValueAtTime(0.01, t + 0.2); // ‡∏´‡∏≤‡∏á‡∏™‡∏±‡πâ‡∏ô

                    // Impact
                    const oscClick = audioCtx.createOscillator();
                    const gainClick = audioCtx.createGain();
                    oscClick.type = 'triangle';
                    oscClick.frequency.setValueAtTime(2000, t);
                    oscClick.frequency.exponentialRampToValueAtTime(200, t + 0.05);
                    gainClick.gain.setValueAtTime(0.8, t);
                    gainClick.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
                    
                    modulator.connect(modGain);
                    modGain.connect(carrier.frequency);
                    carrier.connect(carrierGain).connect(hitGain);
                    oscClick.connect(gainClick).connect(hitGain);

                    carrier.start(t); carrier.stop(t + 0.3);
                    modulator.start(t); modulator.stop(t + 0.3);
                    oscClick.start(t); oscClick.stop(t + 0.1);
                }

            } else if (type === 'right') { 
                // ‡∏Ç‡∏ß‡∏≤: ‡∏ï‡∏∂‡∏á (‡∏¢‡∏±‡∏á‡∏Ñ‡∏á‡∏Ñ‡∏≤‡πÅ‡∏£‡∏Ñ‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÑ‡∏ß‡πâ ‡πÅ‡∏ï‡πà‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ó‡∏∏‡πâ‡∏°)
                
                if (zoneFactor < 0.6) { // === CENTER ===
                    const oscTone = audioCtx.createOscillator();
                    const gainTone = audioCtx.createGain();
                    oscTone.type = 'sine';
                    oscTone.frequency.setValueAtTime(220, t); // ‡∏•‡∏î‡∏•‡∏á‡∏ô‡∏¥‡∏î‡∏´‡∏ô‡πà‡∏≠‡∏¢‡πÉ‡∏´‡πâ‡∏°‡∏µ‡πÄ‡∏ô‡∏∑‡πâ‡∏≠ (‡∏à‡∏≤‡∏Å 340 -> 220)
                    oscTone.frequency.exponentialRampToValueAtTime(120, t + 0.15);
                    gainTone.gain.setValueAtTime(1.0, t);
                    gainTone.gain.exponentialRampToValueAtTime(0.01, t + 0.15); // ‡∏™‡∏±‡πâ‡∏ô

                    const oscWood = audioCtx.createOscillator();
                    const gainWood = audioCtx.createGain();
                    oscWood.type = 'triangle';
                    oscWood.frequency.setValueAtTime(350, t);
                    gainWood.gain.setValueAtTime(0.3, t);
                    gainWood.gain.linearRampToValueAtTime(0.0, t + 0.1);

                    oscTone.connect(gainTone).connect(hitGain);
                    oscWood.connect(gainWood).connect(hitGain);
                    
                    oscTone.start(t); oscTone.stop(t + 0.2);
                    oscWood.start(t); oscWood.stop(t + 0.15);

                } else { // === RIM ===
                    const oscSlap = audioCtx.createOscillator();
                    const gainSlap = audioCtx.createGain();
                    oscSlap.type = 'sawtooth';
                    oscSlap.frequency.setValueAtTime(1200, t);
                    oscSlap.frequency.exponentialRampToValueAtTime(150, t + 0.05);
                    gainSlap.gain.setValueAtTime(0.7, t);
                    gainSlap.gain.exponentialRampToValueAtTime(0.01, t + 0.05);

                    const bufferSize = audioCtx.sampleRate * 0.02; 
                    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                    
                    const noise = audioCtx.createBufferSource();
                    noise.buffer = buffer;
                    const noiseFilter = audioCtx.createBiquadFilter();
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.value = 3000;
                    
                    const gainNoise = audioCtx.createGain();
                    gainNoise.gain.setValueAtTime(0.6, t);
                    gainNoise.gain.exponentialRampToValueAtTime(0.01, t + 0.02);

                    oscSlap.connect(gainSlap).connect(hitGain);
                    noise.connect(noiseFilter).connect(gainNoise).connect(hitGain);
                    
                    oscSlap.start(t); oscSlap.stop(t + 0.1);
                    noise.start(t);
                }
            }
        }

        // --- Interaction Logic with Position Detection ---
        
        function handleInteraction(event, padId, type) {
            // ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ã‡πâ‡∏≥‡∏ã‡πâ‡∏≠‡∏ô‡πÉ‡∏ô‡∏ö‡∏≤‡∏á‡πÄ‡∏ö‡∏£‡∏≤‡∏ß‡πå‡πÄ‡∏ã‡∏≠‡∏£‡πå
            if(event.type === 'touchstart') event.preventDefault();
            
            const pad = document.getElementById(padId);
            const rect = pad.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            // ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Multi-touch
            let touches = event.changedTouches ? Array.from(event.changedTouches) : [{clientX: event.clientX, clientY: event.clientY}];

            touches.forEach(touch => {
                // ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤ touch ‡∏ô‡∏µ‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô element ‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö multi-touch)
                // ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö mouse event ‡πÄ‡∏£‡∏≤‡∏Ç‡πâ‡∏≤‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ‡∏ô‡∏µ‡πâ‡πÄ‡∏û‡∏£‡∏≤‡∏∞‡∏°‡∏±‡∏ô trigger ‡∏ö‡∏ô element ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß
                if (event.changedTouches) {
                    const touchTarget = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (touchTarget !== pad && !pad.contains(touchTarget)) return;
                }

                // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏´‡πà‡∏≤‡∏á‡∏à‡∏≤‡∏Å‡∏à‡∏∏‡∏î‡∏®‡∏π‡∏ô‡∏¢‡πå‡∏Å‡∏•‡∏≤‡∏á (0.0 - 1.0)
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const maxRadius = rect.width / 2;
                
                // Normalized distance (0 = center, 1 = edge)
                let zoneFactor = Math.min(distance / maxRadius, 1.0);

                playSound(type, zoneFactor);

                // Visual Feedback
                pad.classList.remove('active');
                void pad.offsetWidth; // Trigger reflow
                pad.classList.add('active');
                setTimeout(() => pad.classList.remove('active'), 100);

                // Ripple at touch point
                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                ripple.style.left = (touch.clientX - rect.left) + 'px';
                ripple.style.top = (touch.clientY - rect.top) + 'px';
                pad.appendChild(ripple);
                setTimeout(() => ripple.remove(), 400);
            });
        }

        const padLeft = document.getElementById('padLeft');
        const padRight = document.getElementById('padRight');
        const container = document.getElementById('drumContainer');

        // Touch Events
        padLeft.addEventListener('touchstart', (e) => handleInteraction(e, 'padLeft', 'left'), {passive: false});
        padRight.addEventListener('touchstart', (e) => handleInteraction(e, 'padRight', 'right'), {passive: false});

        // Mouse Events
        padLeft.addEventListener('mousedown', (e) => handleInteraction(e, 'padLeft', 'left'));
        padRight.addEventListener('mousedown', (e) => handleInteraction(e, 'padRight', 'right'));

        // Keyboard Support (Fixed zones for keyboard)
        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            // A = Left Center, Z = Left Rim
            if (e.key === 'a') playSound('left', 0.0); // Center
            if (e.key === 'z') playSound('left', 0.8); // Rim
            
            // D = Right Center, C = Right Rim
            if (e.key === 'd') playSound('right', 0.0); // Center
            if (e.key === 'c') playSound('right', 0.8); // Rim
            
            // Visual feedback for keyboard is tricky without mapping, simplified here
        });

        // --- Controls Logic ---
        const btnNotes = document.getElementById('btnNotes');
        btnNotes.addEventListener('click', () => {
            container.classList.toggle('show-notes');
            btnNotes.textContent = container.classList.contains('show-notes') ? "üéµ ‡∏ã‡πà‡∏≠‡∏ô‡πÇ‡∏ô‡πâ‡∏ï" : "üéµ ‡πÇ‡∏ô‡πâ‡∏ï";
        });

        const btnRecord = document.getElementById('btnRecord');
        const btnStop = document.getElementById('btnStop');
        const btnPlay = document.getElementById('btnPlay');
        const btnDownload = document.getElementById('btnDownload');

        btnRecord.addEventListener('click', () => {
            initAudio();
            chunks = [];
            let options = { mimeType: 'audio/webm' };
            if (!MediaRecorder.isTypeSupported('audio/webm')) options = { mimeType: 'audio/mp4' };
            
            try {
                mediaRecorder = new MediaRecorder(dest.stream, options);
            } catch (err) {
                alert("Recording not supported fully");
                mediaRecorder = new MediaRecorder(dest.stream);
            }

            mediaRecorder.ondataavailable = (evt) => chunks.push(evt.data);
            mediaRecorder.onstop = () => {
                recordedBlob = new Blob(chunks, { type: 'audio/webm' });
                audioURL = URL.createObjectURL(recordedBlob);
                playbackAudio.src = audioURL;
                btnPlay.disabled = false;
                btnDownload.disabled = false;
            };

            mediaRecorder.start();
            btnRecord.classList.add('recording');
            btnRecord.disabled = true;
            btnStop.disabled = false;
            btnPlay.disabled = true;
            btnDownload.disabled = true;
        });

        btnStop.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                btnRecord.classList.remove('recording');
                btnRecord.disabled = false;
                btnStop.disabled = true;
            }
        });

        btnPlay.addEventListener('click', () => { if (audioURL) playbackAudio.play(); });

        btnDownload.addEventListener('click', () => {
            if (audioURL) {
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = audioURL;
                a.download = 'thud-drum-solo.webm';
                document.body.appendChild(a);
                a.click();
                setTimeout(() => document.body.removeChild(a), 100);
            }
        });

    </script>
</body>
</html>
