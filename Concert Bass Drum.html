<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Marching Bass Drum (Sample Only)</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&family=Black+Ops+One&display=swap');

        :root {
            --primary-red: #c92a2a;
            --dark-red: #8a1c1c;
            --gold: #ffd43b;
            --silver: #e0e0e0;
            --hoop-color: #111111;
            --head-color: #fcfcfc;
            --bg-color: #121212;
        }

        body {
            font-family: 'Sarabun', sans-serif;
            background-color: var(--bg-color);
            background-image: radial-gradient(circle at center, #2c3e50 0%, #000000 100%);
            color: white;
            margin: 0;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow: hidden;
            touch-action: none;
        }

        header {
            text-align: center;
            padding: 15px;
            background: linear-gradient(to bottom, #2b2b2b, #1a1a1a);
            width: 100%;
            box-shadow: 0 4px 15px rgba(0,0,0,0.8);
            border-bottom: 3px solid var(--primary-red);
            z-index: 10;
            flex-shrink: 0;
        }

        h1 {
            margin: 0;
            font-size: 1.5rem;
            color: white;
            font-family: 'Black Ops One', cursive;
            letter-spacing: 2px;
            text-shadow: 0 2px 5px rgba(0,0,0,0.8);
        }

        /* Status Bar removed as requested */

        .drum-container {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            position: relative;
        }

        /* Marching Bass Drum Styling */
        .drum-pad {
            width: min(70vw, 40vh);
            height: min(70vw, 40vh);
            max-width: 450px;
            max-height: 450px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #ffffff, #f0f0f0 60%, #e0e0e0 100%);
            border: min(3vw, 25px) solid var(--hoop-color);
            box-shadow: 
                0 20px 60px rgba(0,0,0,0.9),
                inset 0 0 20px rgba(0,0,0,0.2),
                0 0 0 4px #888,
                0 0 0 6px #333;
            cursor: pointer;
            position: relative;
            transition: transform 0.05s cubic-bezier(0.1, 0.7, 1.0, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        .drum-pad::before {
            content: '';
            position: absolute;
            top: -14px; left: -14px; right: -14px; bottom: -14px;
            border-radius: 50%;
            border: 3px dashed #aaaaaa;
            z-index: -1;
            opacity: 0.8;
        }

        .drum-pad::after {
            content: '';
            position: absolute;
            width: 80%;
            height: 80%;
            border-radius: 50%;
            box-shadow: inset 0 0 0 20px rgba(255,255,255,0.5); 
            border: 1px solid rgba(0,0,0,0.05);
            pointer-events: none;
        }

        .drum-pad:active, .drum-pad.active {
            transform: scale(0.97);
            box-shadow: 
                0 10px 30px rgba(0,0,0,0.8),
                inset 0 0 40px rgba(0,0,0,0.1),
                0 0 0 4px #888,
                0 0 0 6px #333;
        }

        .drum-label {
            margin-top: 35px;
            font-size: 1.5rem;
            color: white;
            font-family: 'Black Ops One', cursive;
            background: rgba(255,255,255,0.1);
            padding: 5px 20px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.3);
            pointer-events: none;
            text-shadow: 0 2px 4px rgba(0,0,0,1);
            letter-spacing: 1px;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(0,0,0,0.2);
            transform: scale(0);
            animation: ripple-anim 0.25s ease-out;
            pointer-events: none;
        }

        @keyframes ripple-anim {
            to {
                transform: scale(1.6);
                opacity: 0;
            }
        }

        .controls {
            display: flex;
            gap: 15px;
            padding: 25px;
            justify-content: center;
            background: rgba(0,0,0,0.8);
            width: 100%;
            backdrop-filter: blur(5px);
            position: absolute;
            bottom: 0;
            box-sizing: border-box;
            border-top: 2px solid var(--primary-red);
        }

        button.ctrl-btn {
            padding: 12px 24px;
            border: 1px solid #666;
            background: linear-gradient(to bottom, #333, #222);
            color: white;
            border-radius: 2px;
            font-family: 'Sarabun', sans-serif;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 1rem;
            text-transform: uppercase;
        }

        button.ctrl-btn:active {
            transform: scale(0.95);
            background: #111;
        }
        
        button.ctrl-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            color: #888;
        }

        button.ctrl-btn.recording {
            background: var(--primary-red);
            border-color: #ff0000;
            box-shadow: 0 0 10px rgba(255, 0, 0, 0.5);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(201, 42, 42, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(201, 42, 42, 0); }
            100% { box-shadow: 0 0 0 0 rgba(201, 42, 42, 0); }
        }

        #notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 25px 50px;
            border-radius: 4px;
            font-size: 1.2rem;
            border: 1px solid var(--primary-red);
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            z-index: 100;
            text-align: center;
            font-weight: bold;
            font-family: 'Black Ops One', cursive;
        }
    </style>
</head>
<body>

    <header>
        <h1>MARCHING BASS</h1>
    </header>

    <div class="drum-container">
        <div class="drum-pad" id="bigDrum">
        </div>
        <div class="drum-label">CORPS SERIES 28"</div>
    </div>

    <div class="controls">
        <button id="recordBtn" class="ctrl-btn">
            <span>●</span> REC
        </button>
        <button id="stopBtn" class="ctrl-btn" disabled>
            <span>■</span> STOP
        </button>
        <button id="playBtn" class="ctrl-btn" disabled>
            <span>▶</span> PLAY
        </button>
        <button id="downloadBtn" class="ctrl-btn" disabled>
            <span>⬇</span> SAVE
        </button>
    </div>

    <div id="notification">Notification</div>
    <audio id="playbackAudio" style="display:none;"></audio>

    <script>
        // --- Sound Configuration ---
        const soundUrls = {
            'hit': 'basdrum/bassdrum.mp3', // เสียงตีตรงกลาง (Bass)
           'rim': 'basdrum/bassdrumkob.mp3' 
        };

        // --- Audio Engine (Web Audio API) ---
        let audioCtx;
        let masterGain;
        let compressor;
        let dest;
        let mediaRecorder;
        let audioChunks = [];
        let audioBlob;
        let audioUrl;
        
        let loadedBuffers = {};

        function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                
                // Dynamics Compressor - Stabilized
                compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = -12; 
                compressor.knee.value = 30; 
                compressor.ratio.value = 15; 
                compressor.attack.value = 0.003; 
                compressor.release.value = 0.15;

                // Master Volume - Adjusted to avoid distortion with loaded files
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 3.5; 
                
                // Removed Master Lowpass Filter to allow full fidelity for loaded sounds
                
                // Chain: Master -> Compressor -> Dest
                masterGain.connect(compressor);
                compressor.connect(audioCtx.destination);
                
                dest = audioCtx.createMediaStreamDestination();
                compressor.connect(dest);

                preloadSounds();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- Resource Loading ---
        async function preloadSounds() {
            for (const key in soundUrls) {
                const url = soundUrls[key];
                if (url && url.length > 0) {
                    try {
                        const response = await fetch(url);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                        loadedBuffers[key] = audioBuffer;
                        // No UI update/alert as requested
                    } catch (error) {
                        console.warn(`Failed to load sound for ${key}:`, error);
                    }
                }
            }
        }

        // --- Play Logic (Bass & Rim) ---
        function playDrumSound(type, intensity = 1.0) {
            initAudio();
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
            
            // Only play if buffer is loaded (No Synthesis Fallback)
            if (loadedBuffers[type]) {
                 playSample(loadedBuffers[type], intensity);
            } else if (type === 'rim' && loadedBuffers['hit']) {
                 // Fallback for rim if only hit is loaded (using hit sample at lower volume)
                 playSample(loadedBuffers['hit'], intensity * 0.25);
            }
        }

        // 1. Sample Player (Improved Stability)
        function playSample(buffer, intensity) {
            const t = audioCtx.currentTime;
            const source = audioCtx.createBufferSource();
            source.buffer = buffer;
            
            const sampleGain = audioCtx.createGain();
            // Micro-fade in/out to prevent popping/clicks (Stable playback)
            const vol = 0.8 * intensity;
            sampleGain.gain.setValueAtTime(0, t);
            sampleGain.gain.linearRampToValueAtTime(vol, t + 0.002); // 2ms attack
            
            source.connect(sampleGain);
            sampleGain.connect(masterGain);
            source.start(t);
        }

        // --- Interaction Logic (Rim vs Center) ---
        const bigDrum = document.getElementById('bigDrum');

        function triggerDrum(e, isTouch = false) {
            e.preventDefault(); 
            
            const rect = bigDrum.getBoundingClientRect();
            if (isTouch && e.changedTouches) {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    processHit(e.changedTouches[i].clientX, e.changedTouches[i].clientY, rect);
                }
            } else {
                processHit(e.clientX, e.clientY, rect);
            }
        }

        function processHit(x, y, rect) {
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            const dist = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
            const radius = rect.width / 2;
            const normalizedDist = dist / radius; 

            // Rim Zone > 75%
            if (normalizedDist > 0.75) {
                const intensity = Math.max(0.2, 1 - ((normalizedDist - 0.75) / 0.5));
                playDrumSound('rim', intensity);
            } else {
                playDrumSound('hit');
            }

            // Visual feedback
            bigDrum.classList.add('active');
            createRipple(x - rect.left, y - rect.top);
            
            setTimeout(() => {
                bigDrum.classList.remove('active');
            }, 80);
        }

        function createRipple(x, y) {
            const ripple = document.createElement('div');
            ripple.classList.add('ripple');
            const size = 100;
            ripple.style.width = size + 'px';
            ripple.style.height = size + 'px';
            ripple.style.left = (x - size/2) + 'px'; 
            ripple.style.top = (y - size/2) + 'px';
            
            bigDrum.appendChild(ripple);
            setTimeout(() => ripple.remove(), 300);
        }

        // Event Listeners
        bigDrum.addEventListener('mousedown', (e) => triggerDrum(e, false));
        bigDrum.addEventListener('touchstart', (e) => triggerDrum(e, true), { passive: false });

        window.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            if (e.code === 'Space' || e.key === ' ') {
                playDrumSound('hit');
                const rect = bigDrum.getBoundingClientRect();
                bigDrum.classList.add('active');
                createRipple(rect.width/2, rect.height/2);
                setTimeout(() => bigDrum.classList.remove('active'), 80);
            } else if (e.key.toLowerCase() === 'r') {
                playDrumSound('rim', 0.8);
                 const rect = bigDrum.getBoundingClientRect();
                 bigDrum.classList.add('active');
                 createRipple(rect.width/2, 20); 
                 setTimeout(() => bigDrum.classList.remove('active'), 80);
            }
        });

        // --- Recording Logic ---
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const playBtn = document.getElementById('playBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const playbackAudio = document.getElementById('playbackAudio');

        recordBtn.addEventListener('click', startRecording);
        stopBtn.addEventListener('click', stopRecording);
        playBtn.addEventListener('click', playRecording);
        downloadBtn.addEventListener('click', downloadRecording);

        function startRecording() {
            initAudio();
            audioChunks = [];
            
            const options = MediaRecorder.isTypeSupported('audio/webm') 
                ? { mimeType: 'audio/webm' } 
                : { mimeType: 'audio/mp4' };

            try {
                mediaRecorder = new MediaRecorder(dest.stream, options);
            } catch (e) {
                showToast("ไม่รองรับการอัดเสียง");
                return;
            }
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) audioChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                audioBlob = new Blob(audioChunks, { type: 'audio/wav' });
                audioUrl = URL.createObjectURL(audioBlob);
                playbackAudio.src = audioUrl;
                
                playBtn.disabled = false;
                downloadBtn.disabled = false;
                showToast("บันทึกเสร็จสิ้น!");
            };

            mediaRecorder.start();
            recordBtn.classList.add('recording');
            recordBtn.innerHTML = "<span>●</span> REC...";
            recordBtn.disabled = true;
            stopBtn.disabled = false;
            playBtn.disabled = true;
            downloadBtn.disabled = true;
            
            showToast("เริ่มอัดเสียง...");
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                recordBtn.classList.remove('recording');
                recordBtn.innerHTML = "<span>●</span> REC";
                recordBtn.disabled = false;
                stopBtn.disabled = true;
            }
        }

        function playRecording() {
            if (audioUrl) {
                playbackAudio.play();
                showToast("กำลังเล่น...");
            }
        }

        function downloadRecording() {
            if (audioUrl) {
                const a = document.createElement('a');
                a.href = audioUrl;
                a.download = `marching_bass_${new Date().getTime()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }
        }

        function showToast(msg) {
            const el = document.getElementById('notification');
            el.innerText = msg;
            el.style.opacity = '1';
            setTimeout(() => {
                el.style.opacity = '0';
            }, 2000);
        }

    </script>
</body>
</html>
