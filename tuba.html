<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Realistic Tuba Mobile</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ã‡∏π‡∏° */
        * {
            user-select: none;
            -webkit-user-select: none;
            touch-action: manipulation;
            box-sizing: border-box;
        }

        body {
            background-color: #1a1a1a;
            color: white;
            height: 100vh;
            width: 100vw;
            overflow: hidden; /* ‡∏´‡πâ‡∏≤‡∏°‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô */
            display: flex;
            flex-direction: column;
            font-family: 'Sarabun', sans-serif;
            overscroll-behavior: none;
        }

        /* ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏•‡∏≤‡∏¢‡∏ó‡∏≠‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏á */
        .brass-bg {
            background: radial-gradient(circle at 30% 30%, #ffd700, #b8860b, #5e4305);
            box-shadow: inset 0 0 50px #000;
        }

        /* ‡∏î‡∏µ‡πÑ‡∏ã‡∏ô‡πå‡∏õ‡∏∏‡πà‡∏°‡∏•‡∏π‡∏Å‡∏™‡∏π‡∏ö (Valves) */
        .valve-btn {
            background: linear-gradient(145deg, #fefefe, #dcdcdc, #a9a9a9);
            border: 4px solid #b8860b;
            border-radius: 50%;
            box-shadow: 
                0 10px 15px -3px rgba(0, 0, 0, 0.5), 
                inset 0 2px 5px rgba(255, 255, 255, 0.8),
                inset 0 -2px 5px rgba(0, 0, 0, 0.2);
            transition: transform 0.05s, box-shadow 0.05s;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #333;
            font-weight: bold;
            font-size: 1.2rem;
            z-index: 10;
        }

        .valve-btn:active, .valve-btn.active {
            transform: translateY(10px) scale(0.95);
            background: linear-gradient(145deg, #a9a9a9, #dcdcdc);
            box-shadow: 
                0 2px 5px rgba(0, 0, 0, 0.5),
                inset 0 5px 10px rgba(0, 0, 0, 0.3);
        }

        /* ‡∏Å‡πâ‡∏≤‡∏ô‡∏•‡∏π‡∏Å‡∏™‡∏π‡∏ö */
        .valve-stem {
            position: absolute;
            top: -100%;
            bottom: 50%;
            left: 50%;
            width: 10px;
            transform: translateX(-50%);
            background: linear-gradient(90deg, #888, #fff, #888);
            z-index: -1;
        }

        /* ‡∏ó‡πà‡∏≠‡∏•‡∏°‡∏ó‡∏π‡∏ö‡∏≤ (‡∏ï‡∏Å‡πÅ‡∏ï‡πà‡∏á) */
        .tuba-pipe {
            position: absolute;
            background: linear-gradient(90deg, #b8860b, #ffd700, #b8860b);
            border-radius: 20px;
            box-shadow: 5px 5px 15px rgba(0,0,0,0.5);
            z-index: 0;
        }

        /* ‡πÑ‡∏ü‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏≠‡∏±‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á */
        .led {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background-color: #333;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.5);
            margin-right: 6px;
        }
        .led.recording {
            background-color: #ff3333;
            box-shadow: 0 0 10px #ff3333;
            animation: pulse 1s infinite;
        }
        .led.playing {
            background-color: #33ff33;
            box-shadow: 0 0 10px #33ff33;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* ‡∏à‡∏±‡∏î layout ‡πÅ‡∏ö‡∏ö Grid ‡πÉ‡∏´‡πâ‡πÅ‡∏ô‡πà‡∏ô‡∏à‡∏≠ */
        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            position: relative;
        }

        .bell-section {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        /* ‡∏õ‡∏≤‡∏Å‡πÅ‡∏ï‡∏£ */
        .tuba-bell {
            width: 60vw;
            height: 60vw;
            max-width: 300px;
            max-height: 300px;
            background: radial-gradient(circle, #2a1d00 10%, #b8860b 40%, #ffd700 80%);
            border-radius: 50%;
            border: 8px solid #8b6508;
            box-shadow: 
                inset 0 0 60px #000,
                0 10px 30px rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: rgba(255,255,255,0.2);
            font-size: 1.5rem;
            text-transform: uppercase;
            font-weight: bold;
        }

        .controls-section {
            display: flex;
            justify-content: center;
            gap: 10px; /* ‡∏•‡∏î gap ‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà‡∏û‡∏≠‡∏î‡∏µ */
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            margin-bottom: 10px;
            flex-wrap: wrap; /* ‡πÉ‡∏´‡πâ‡∏õ‡∏∏‡πà‡∏°‡πÄ‡∏£‡∏µ‡∏¢‡∏á‡∏ö‡∏£‡∏£‡∏ó‡∏±‡∏î‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ñ‡πâ‡∏≤‡∏à‡∏≠‡πÄ‡∏•‡πá‡∏Å‡∏°‡∏≤‡∏Å */
        }

        .valves-container {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.2);
            border-radius: 20px 20px 0 0;
            padding-bottom: 30px; /* Space for thumb */
        }
        
        button.control-btn {
            background: #444;
            border: 1px solid #666;
            color: #ddd;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            white-space: nowrap;
        }
        button.control-btn:active {
            background: #222;
        }
        button.control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ‡∏ã‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠ Start */
        #start-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }
    </style>
</head>
<body>

    <!-- Overlay ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏° AudioContext -->
    <div id="start-overlay">
        <div class="tuba-bell" style="width: 150px; height: 150px; margin-bottom: 20px;">
            <span style="font-size: 3rem;">üé∫</span>
        </div>
        <h1 class="text-2xl font-bold text-yellow-500 mb-2">Tuba Mobile Pro</h1>
        <p class="text-gray-300 mb-6">‡πÅ‡∏ï‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô</p>
        <button id="start-btn" class="bg-yellow-600 hover:bg-yellow-700 text-white font-bold py-3 px-8 rounded-full shadow-lg transform transition hover:scale-105">
            ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏õ‡πà‡∏≤
        </button>
    </div>

    <div class="main-container brass-bg">
        <!-- ‡∏™‡πà‡∏ß‡∏ô‡∏´‡∏±‡∏ß‡πÅ‡∏•‡∏∞‡πÇ‡∏•‡πÇ‡∏Å‡πâ -->
        <div class="flex justify-between items-center px-4 py-2">
            <h1 class="text-yellow-200 text-lg font-bold drop-shadow-md">Tuba Sim üáπüá≠</h1>
            <div id="status-display" class="text-xs text-yellow-100 opacity-70">Ready</div>
        </div>

        <!-- ‡∏™‡πà‡∏ß‡∏ô‡∏õ‡∏≤‡∏Å‡πÅ‡∏ï‡∏£ (Visual) -->
        <div class="bell-section">
            <div class="tuba-pipe" style="width: 200px; height: 20px; top: 50%; left: -50px; transform: rotate(-10deg);"></div>
            <div class="tuba-bell" id="bell-visual">
                TUBA
            </div>
        </div>

        <!-- ‡πÅ‡∏ú‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á -->
        <div class="controls-section">
            <div class="flex items-center text-white mr-2" style="width: 100%; justify-content: center; margin-bottom: 5px;">
                <div id="rec-led" class="led"></div>
                <span id="timer" class="text-xs font-mono ml-1">00:00</span>
            </div>
            <button id="btn-rec" class="control-btn text-red-300 border-red-900">
                <span>‚óè ‡∏≠‡∏±‡∏î</span>
            </button>
            <button id="btn-stop" class="control-btn text-gray-300" disabled>
                <span>‚ñ† ‡∏´‡∏¢‡∏∏‡∏î</span>
            </button>
            <button id="btn-play" class="control-btn text-green-300 border-green-900" disabled>
                <span>‚ñ∂ ‡πÄ‡∏•‡πà‡∏ô</span>
            </button>
            <!-- ‡∏õ‡∏∏‡πà‡∏°‡πÉ‡∏´‡∏°‡πà: ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î -->
            <button id="btn-download" class="control-btn text-blue-300 border-blue-900" disabled>
                <span>üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</span>
            </button>
        </div>

        <!-- ‡πÅ‡∏ú‡∏á‡∏õ‡∏∏‡πà‡∏°‡∏Å‡∏î (Valves) -->
        <!-- ‡πÄ‡∏£‡∏≤‡∏à‡∏∞ mapping ‡πÄ‡∏õ‡πá‡∏ô‡πÇ‡∏ô‡πâ‡∏ï‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÄ‡∏•‡πà‡∏ô‡∏á‡πà‡∏≤‡∏¢‡∏ö‡∏ô‡∏°‡∏∑‡∏≠‡∏ñ‡∏∑‡∏≠ -->
        <div class="flex flex-col items-center w-full">
            <div class="text-yellow-400 text-xs mb-1 font-bold tracking-widest">LOW OCTAVE</div>
            <div class="valves-container w-full">
                <!-- Low C (C2) to F (F2) -->
                <div class="valve-btn h-20 w-full" data-note="C2">
                    <div class="valve-stem"></div>C
                </div>
                <div class="valve-btn h-20 w-full" data-note="D2">
                    <div class="valve-stem"></div>D
                </div>
                <div class="valve-btn h-20 w-full" data-note="E2">
                    <div class="valve-stem"></div>E
                </div>
                <div class="valve-btn h-20 w-full" data-note="F2">
                    <div class="valve-stem"></div>F
                </div>
                <!-- G (G2) to C (C3) -->
                <div class="valve-btn h-20 w-full mt-4" data-note="G2">
                    <div class="valve-stem"></div>G
                </div>
                <div class="valve-btn h-20 w-full mt-4" data-note="A2">
                    <div class="valve-stem"></div>A
                </div>
                <div class="valve-btn h-20 w-full mt-4" data-note="B2">
                    <div class="valve-stem"></div>B
                </div>
                <div class="valve-btn h-20 w-full mt-4" data-note="C3">
                    <div class="valve-stem"></div>C3
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- Audio Engine ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let masterGain;
        let compressor;
        
        // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÇ‡∏ô‡πâ‡∏ï (Tuba Range: Low)
        const notesFreq = {
            "C2": 65.41, "C#2": 69.30, "D2": 73.42, "D#2": 77.78, 
            "E2": 82.41, "F2": 87.31, "F#2": 92.50, "G2": 98.00, 
            "G#2": 103.83, "A2": 110.00, "A#2": 116.54, "B2": 123.47, 
            "C3": 130.81
        };

        const activeOscillators = {}; // ‡πÄ‡∏Å‡πá‡∏ö Oscillator ‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏•‡πà‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ñ‡πâ‡∏≤‡∏á

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
                
                // Compressor ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏á‡∏£‡∏ß‡∏°‡πÅ‡∏•‡∏∞‡πÉ‡∏´‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏ô‡πà‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô
                compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
                compressor.knee.setValueAtTime(30, audioCtx.currentTime);
                compressor.ratio.setValueAtTime(12, audioCtx.currentTime);
                compressor.attack.setValueAtTime(0.003, audioCtx.currentTime);
                compressor.release.setValueAtTime(0.25, audioCtx.currentTime);

                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.8;

                compressor.connect(masterGain);
                masterGain.connect(audioCtx.destination);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á Tuba (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Realtime)
        function createTubaVoice(context, freq, t, dest) {
            const osc = context.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, t);

            const subOsc = context.createOscillator();
            subOsc.type = 'triangle';
            subOsc.frequency.setValueAtTime(freq, t);

            const filter = context.createBiquadFilter();
            filter.type = 'lowpass';
            filter.Q.value = 1; 
            filter.frequency.setValueAtTime(200, t); 
            filter.frequency.exponentialRampToValueAtTime(600, t + 0.1); 
            filter.frequency.exponentialRampToValueAtTime(300, t + 0.5);

            const gainNode = context.createGain();
            gainNode.gain.setValueAtTime(0, t);
            gainNode.gain.linearRampToValueAtTime(1.0, t + 0.05); 
            gainNode.gain.exponentialRampToValueAtTime(0.7, t + 0.3);

            osc.connect(filter);
            subOsc.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(dest);

            osc.start(t);
            subOsc.start(t);

            return { osc, subOsc, gainNode, filter };
        }

        function playNote(note) {
            if (!audioCtx) return;
            const freq = notesFreq[note];
            if (!freq) return;

            if (activeOscillators[note]) {
                stopNote(note);
            }

            const t = audioCtx.currentTime;
            
            // ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏Å‡∏•‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á
            const voice = createTubaVoice(audioCtx, freq, t, compressor);

            activeOscillators[note] = voice;

            // Visual Feedback
            document.getElementById('bell-visual').style.transform = 'scale(1.1)';
            document.getElementById('bell-visual').style.borderColor = '#ffd700';

            // Recording Logic
            if (isRecording) {
                recordedEvents.push({
                    type: 'on',
                    note: note,
                    time: Date.now() - recordingStartTime
                });
            }
        }

        function stopNote(note) {
            if (!audioCtx || !activeOscillators[note]) return;

            const voice = activeOscillators[note];
            const t = audioCtx.currentTime;
            
            // Release Envelope
            voice.gainNode.gain.cancelScheduledValues(t);
            voice.gainNode.gain.setValueAtTime(voice.gainNode.gain.value, t);
            voice.gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

            voice.osc.stop(t + 0.3);
            voice.subOsc.stop(t + 0.3);

            setTimeout(() => {
                if(activeOscillators[note] === voice) {
                    delete activeOscillators[note];
                }
            }, 350);

            // Visual Feedback Reset
            document.getElementById('bell-visual').style.transform = 'scale(1)';
            document.getElementById('bell-visual').style.borderColor = '#8b6508';

            // Recording Logic
            if (isRecording) {
                recordedEvents.push({
                    type: 'off',
                    note: note,
                    time: Date.now() - recordingStartTime
                });
            }
        }

        // --- Interaction Logic ---
        const buttons = document.querySelectorAll('.valve-btn');

        buttons.forEach(btn => {
            const note = btn.dataset.note;

            // Touch events for mobile
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); 
                btn.classList.add('active');
                playNote(note);
            }, { passive: false });

            btn.addEventListener('touchend', (e) => {
                e.preventDefault();
                btn.classList.remove('active');
                stopNote(note);
            }, { passive: false });

            // Mouse events for desktop testing
            btn.addEventListener('mousedown', () => {
                btn.classList.add('active');
                playNote(note);
            });

            btn.addEventListener('mouseup', () => {
                btn.classList.remove('active');
                stopNote(note);
            });
            
            btn.addEventListener('mouseleave', () => {
                if(btn.classList.contains('active')) {
                   btn.classList.remove('active');
                   stopNote(note);
                }
            });
        });

        // --- Recording & Downloading Logic ---
        let isRecording = false;
        let isPlaying = false;
        let recordingStartTime = 0;
        let recordedEvents = [];
        let playbackTimeouts = [];

        const btnRec = document.getElementById('btn-rec');
        const btnStop = document.getElementById('btn-stop');
        const btnPlay = document.getElementById('btn-play');
        const btnDownload = document.getElementById('btn-download');
        const recLed = document.getElementById('rec-led');
        const timerDisplay = document.getElementById('timer');
        const statusDisplay = document.getElementById('status-display');

        function updateTimer() {
            if (!isRecording && !isPlaying) return;
            const elapsed = Date.now() - recordingStartTime;
            const seconds = Math.floor(elapsed / 1000);
            const ms = Math.floor((elapsed % 1000) / 10);
            timerDisplay.textContent = `${seconds.toString().padStart(2, '0')}:${ms.toString().padStart(2, '0')}`;
            requestAnimationFrame(updateTimer);
        }

        btnRec.addEventListener('click', () => {
            if (isPlaying) stopPlayback();
            
            isRecording = true;
            recordedEvents = [];
            recordingStartTime = Date.now();
            
            recLed.classList.add('recording');
            btnRec.disabled = true;
            btnPlay.disabled = true;
            btnDownload.disabled = true;
            btnStop.disabled = false;
            statusDisplay.textContent = "Recording...";
            
            updateTimer();
        });

        function stopAll() {
             // Stop recording
             if (isRecording) {
                isRecording = false;
                recLed.classList.remove('recording');
                statusDisplay.textContent = "Recorded";
            }
            
            // Stop playback
            if (isPlaying) {
                stopPlayback();
            }

            btnRec.disabled = false;
            btnStop.disabled = true;
            const hasData = recordedEvents.length > 0;
            btnPlay.disabled = !hasData;
            btnDownload.disabled = !hasData;
        }

        btnStop.addEventListener('click', stopAll);

        function stopPlayback() {
            isPlaying = false;
            recLed.classList.remove('playing');
            statusDisplay.textContent = "Ready";
            playbackTimeouts.forEach(id => clearTimeout(id));
            playbackTimeouts = [];
            Object.keys(activeOscillators).forEach(note => stopNote(note));
            buttons.forEach(b => b.classList.remove('active'));
        }

        btnPlay.addEventListener('click', () => {
            if (recordedEvents.length === 0) return;
            
            isPlaying = true;
            recLed.classList.add('playing');
            btnRec.disabled = true;
            btnPlay.disabled = true;
            btnDownload.disabled = true;
            btnStop.disabled = false;
            statusDisplay.textContent = "Playing...";
            
            recordingStartTime = Date.now();
            updateTimer();

            recordedEvents.forEach(event => {
                const timeoutId = setTimeout(() => {
                    if (!isPlaying) return;
                    
                    const btn = document.querySelector(`.valve-btn[data-note="${event.note}"]`);
                    
                    if (event.type === 'on') {
                        playNote(event.note);
                        if (btn) btn.classList.add('active');
                    } else {
                        stopNote(event.note);
                        if (btn) btn.classList.remove('active');
                    }
                }, event.time);
                
                playbackTimeouts.push(timeoutId);
            });

            const lastEventTime = recordedEvents[recordedEvents.length-1].time;
            const endTimeout = setTimeout(() => {
                stopAll();
            }, lastEventTime + 1000);
            playbackTimeouts.push(endTimeout);
        });

        // --- Render and Download Logic ---
        btnDownload.addEventListener('click', async () => {
            if (recordedEvents.length === 0) return;
            
            statusDisplay.textContent = "Rendering...";
            btnDownload.disabled = true;
            btnDownload.innerHTML = "<span>‚è≥ ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà...</span>";

            try {
                // 1. Calculate duration
                const lastTime = recordedEvents[recordedEvents.length - 1].time;
                const durationSeconds = (lastTime + 1000) / 1000;
                
                // 2. Setup Offline Context
                const offlineCtx = new OfflineAudioContext(2, 44100 * durationSeconds, 44100);
                
                // Compressor for Offline
                const offlineCompressor = offlineCtx.createDynamicsCompressor();
                offlineCompressor.threshold.value = -24;
                offlineCompressor.knee.value = 30;
                offlineCompressor.ratio.value = 12;
                offlineCompressor.attack.value = 0.003;
                offlineCompressor.release.value = 0.25;
                offlineCompressor.connect(offlineCtx.destination);

                const offlineVoices = {};

                // 3. Schedule events
                recordedEvents.forEach(event => {
                    const t = event.time / 1000;
                    if (event.type === 'on') {
                        const freq = notesFreq[event.note];
                        // Create voice attached to offline compressor
                        const voice = createTubaVoice(offlineCtx, freq, t, offlineCompressor);
                        offlineVoices[event.note] = voice;
                    } else if (event.type === 'off') {
                        const voice = offlineVoices[event.note];
                        if (voice) {
                            // Release Envelope
                            voice.gainNode.gain.cancelScheduledValues(t);
                            voice.gainNode.gain.setValueAtTime(voice.gainNode.gain.value, t); // approximate current value logic omitted for simplicity in offline, just taking last target
                            // Note: for offline exact value tracking needs more complex math, but simple ramp works for short notes
                            voice.gainNode.gain.exponentialRampToValueAtTime(0.001, t + 0.3);

                            voice.osc.stop(t + 0.3);
                            voice.subOsc.stop(t + 0.3);
                            
                            // Replace in map to handle repeated notes correctly, though usually we'd use unique IDs.
                            // Since JS is single threaded and events are ordered, this basic logic holds for non-overlapping same-note.
                        }
                    }
                });

                // 4. Render
                const renderedBuffer = await offlineCtx.startRendering();

                // 5. Convert to WAV
                const wavBlob = bufferToWave(renderedBuffer, renderedBuffer.length);
                
                // 6. Download
                const url = URL.createObjectURL(wavBlob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `tuba_recording_${Date.now()}.wav`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                
                statusDisplay.textContent = "Saved!";
            } catch (err) {
                console.error(err);
                statusDisplay.textContent = "Error saving";
            } finally {
                btnDownload.disabled = false;
                btnDownload.innerHTML = "<span>üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å</span>";
                setTimeout(() => { statusDisplay.textContent = "Recorded"; }, 2000);
            }
        });

        // Helper: Convert AudioBuffer to WAV Blob
        function bufferToWave(abuffer, len) {
            let numOfChan = abuffer.numberOfChannels,
                length = len * numOfChan * 2 + 44,
                buffer = new ArrayBuffer(length),
                view = new DataView(buffer),
                channels = [], i, sample,
                offset = 0,
                pos = 0;

            // write WAVE header
            setUint32(0x46464952);                         // "RIFF"
            setUint32(length - 8);                         // file length - 8
            setUint32(0x45564157);                         // "WAVE"

            setUint32(0x20746d66);                         // "fmt " chunk
            setUint32(16);                                 // length = 16
            setUint16(1);                                  // PCM (uncompressed)
            setUint16(numOfChan);
            setUint32(abuffer.sampleRate);
            setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
            setUint16(numOfChan * 2);                      // block-align
            setUint16(16);                                 // 16-bit (hardcoded in this ex)

            setUint32(0x61746164);                         // "data" - chunk
            setUint32(length - pos - 4);                   // chunk length

            // write interleaved data
            for(i = 0; i < abuffer.numberOfChannels; i++)
                channels.push(abuffer.getChannelData(i));

            while(pos < len) {
                for(i = 0; i < numOfChan; i++) {             // interleave channels
                    sample = Math.max(-1, Math.min(1, channels[i][pos])); // clamp
                    sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; // scale to 16-bit signed int
                    view.setInt16(44 + offset, sample, true);          // write 16-bit sample
                    offset += 2;
                }
                pos++;
            }

            return new Blob([buffer], {type: "audio/wav"});

            function setUint16(data) {
                view.setUint16(pos, data, true);
                pos += 2;
            }
            function setUint32(data) {
                view.setUint32(pos, data, true);
                pos += 4;
            }
        }

        // --- Start Overlay ---
        document.getElementById('start-btn').addEventListener('click', () => {
            initAudio();
            document.getElementById('start-overlay').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('start-overlay').style.display = 'none';
            }, 500);
        });

    </script>
</body>
</html>