<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>‡∏Å‡∏•‡∏≠‡∏á‡∏™‡∏≠‡∏á‡∏´‡∏ô‡πâ‡∏≤ - Sample Playback</title>
    <style>
        /* ‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡πÅ‡∏•‡∏∞‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô */
        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background: #1a1a1a;
            background: radial-gradient(circle, #2c2c2c 0%, #000000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            font-family: 'Sarabun', sans-serif;
            touch-action: none;
        }

        /* ‡πÅ‡∏ú‡∏á‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏≤‡∏ô‡∏ö‡∏ô */
        .controls {
            position: absolute;
            top: 20px;
            display: flex;
            gap: 10px;
            background: rgba(255, 255, 255, 0.1);
            padding: 10px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            z-index: 100;
        }

        .btn {
            background: #444;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
        }

        .btn:active {
            transform: scale(0.95);
        }

        .btn.recording {
            background: #ff4444;
            animation: pulse 1s infinite;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡πÇ‡∏´‡∏•‡∏î */
        .loading-status {
            position: absolute;
            top: 70px;
            color: #aaa;
            font-size: 12px;
            background: rgba(0,0,0,0.5);
            padding: 4px 8px;
            border-radius: 4px;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        /* ‡∏ï‡∏±‡∏ß‡∏Å‡∏•‡∏≠‡∏á */
        .drum-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 90vw;
            height: 60vh;
            position: relative;
        }

        /* ‡πÇ‡∏Ñ‡∏£‡∏á‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡∏≠‡∏á (‡∏ö‡∏≠‡∏î‡∏µ‡πâ‡πÑ‡∏°‡πâ) */
        .drum-body {
            width: 80%;
            height: 100%;
            background: linear-gradient(90deg, #5d4037 0%, #8d6e63 20%, #a1887f 50%, #8d6e63 80%, #5d4037 100%);
            border-radius: 20px;
            position: absolute;
            z-index: 1;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8) inset, 0 20px 50px rgba(0,0,0,0.5);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* ‡∏•‡∏≤‡∏¢‡πÑ‡∏°‡πâ */
        .wood-texture {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            opacity: 0.3;
            background-image: repeating-linear-gradient(45deg, transparent, transparent 10px, #3e2723 10px, #3e2723 12px);
            border-radius: 20px;
            pointer-events: none;
        }

        /* ‡∏´‡∏ô‡∏±‡∏á‡∏Å‡∏•‡∏≠‡∏á (Head) */
        .drum-head {
            position: relative;
            z-index: 2;
            background: radial-gradient(circle at 30% 30%, #fff3e0, #d7ccc8, #a1887f);
            border-radius: 50%;
            box-shadow: 
                inset 0 0 20px rgba(0,0,0,0.5),
                0 0 0 8px #3e2723, /* ‡∏Ç‡∏≠‡∏ö‡πÑ‡∏°‡πâ */
                0 0 0 12px #5d4037, /* ‡∏Ç‡∏≠‡∏ö‡πÄ‡∏ä‡∏∑‡∏≠‡∏Å */
                5px 0 15px rgba(0,0,0,0.5);
            cursor: pointer;
            transition: transform 0.05s;
            display: flex;
            justify-content: center;
            align-items: center;
            -webkit-tap-highlight-color: transparent;
            overflow: hidden; 
        }

        .drum-head:active, .drum-head.active {
            transform: scale(0.96);
            background: radial-gradient(circle at 30% 30%, #ffe0b2, #d7ccc8, #8d6e63);
        }

        /* ‡πÇ‡∏ã‡∏ô‡∏™‡∏±‡∏°‡∏ú‡∏±‡∏™‡∏û‡∏¥‡πÄ‡∏®‡∏© */
        .hit-zone-indicator {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            pointer-events: none;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 60%, rgba(255,200,100,0.2) 61%);
            opacity: 0.5;
        }

        /* ‡∏´‡∏ô‡πâ‡∏≤‡∏ã‡πâ‡∏≤‡∏¢ (‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏∏‡πâ‡∏°/‡πÉ‡∏´‡∏ç‡πà) */
        .head-left {
            width: 35vh;
            height: 35vh;
            max-width: 45vw;
            max-height: 45vw;
            margin-left: -5%;
        }

        /* ‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏ß‡∏≤ (‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏´‡∏•‡∏°/‡πÄ‡∏•‡πá‡∏Å) */
        .head-right {
            width: 30vh;
            height: 30vh;
            max-width: 40vw;
            max-height: 40vw;
            margin-right: -5%;
        }

        /* ‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á‡πÇ‡∏ô‡πâ‡∏ï */
        .note-label {
            position: absolute;
            color: rgba(62, 39, 35, 0.8);
            font-weight: bold;
            font-size: 2rem;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            text-shadow: 1px 1px 0px rgba(255,255,255,0.3);
            z-index: 10;
        }
        
        .show-notes .note-label {
            opacity: 1;
        }

        .ripple {
            position: absolute;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            transform: scale(0);
            animation: ripple-anim 0.4s linear;
            pointer-events: none;
        }

        @keyframes ripple-anim {
            to {
                transform: scale(2.5);
                opacity: 0;
            }
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); }
        }

        .footer-text {
            position: absolute;
            bottom: 10px;
            color: #666;
            font-size: 12px;
            text-align: center;
        }
    </style>
</head>
<body>

    <div class="controls">
        <button class="btn" id="btnNotes">üéµ ‡πÇ‡∏ô‡πâ‡∏ï</button>
        <button class="btn" id="btnRecord">üî¥ ‡∏≠‡∏±‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á</button>
        <button class="btn" id="btnStop" disabled>‚èπÔ∏è ‡∏´‡∏¢‡∏∏‡∏î</button>
        <button class="btn" id="btnPlay" disabled>‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô</button>
        <button class="btn" id="btnDownload" disabled>‚¨áÔ∏è ‡πÇ‡∏´‡∏•‡∏î</button>
    </div>

    <div id="loadingStatus" class="loading-status">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á...</div>

    <div class="drum-container" id="drumContainer">
        <div class="drum-body">
            <div class="wood-texture"></div>
            <div style="width:100%; height: 2px; background:#3e2723; position:absolute; top:20%;"></div>
            <div style="width:100%; height: 2px; background:#3e2723; position:absolute; bottom:20%;"></div>
            <div style="width:100%; height: 2px; background:#3e2723; position:absolute; top:50%;"></div>
        </div>

        <!-- ‡∏´‡∏ô‡πâ‡∏≤‡∏ã‡πâ‡∏≤‡∏¢ (‡∏ó‡∏∏‡πâ‡∏°) -->
        <div class="drum-head head-left" id="padLeft">
            <div class="hit-zone-indicator"></div>
            <span class="note-label">‡∏ï‡∏∏‡πâ‡∏°/‡∏Ç‡∏≠‡∏ö</span>
        </div>

        <!-- ‡∏´‡∏ô‡πâ‡∏≤‡∏Ç‡∏ß‡∏≤ (‡πÅ‡∏´‡∏•‡∏°) -->
        <div class="drum-head head-right" id="padRight">
            <div class="hit-zone-indicator"></div>
            <span class="note-label">‡∏ï‡∏∂‡∏á/‡πÅ‡∏õ‡πä‡∏∞</span>
        </div>
    </div>

    <div class="footer-text">
        ‡∏ï‡∏µ‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á: ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏±‡πâ‡∏ô‡∏Å‡∏£‡∏∞‡∏ä‡∏±‡∏ö | ‡∏ï‡∏µ‡∏Ç‡∏≠‡∏ö: ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÇ‡∏•‡∏´‡∏∞/Slap<br>
        ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö Sample Playback
    </div>

    <script>
        // --- 1. Sound Configuration ---
        // ‡πÉ‡∏™‡πà‡∏•‡∏¥‡∏á‡∏Å‡πå‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ (.mp3, .wav, .webm)
        // ‡∏´‡∏≤‡∏Å‡∏õ‡∏•‡πà‡∏≠‡∏¢‡∏ß‡πà‡∏≤‡∏á ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏±‡∏á‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏≥‡∏£‡∏≠‡∏á‡πÉ‡∏´‡πâ‡πÅ‡∏ó‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÅ‡∏≠‡∏õ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ
        const soundUrls = {
            leftCenter: "kongkang/joman.wav", // ‡πÄ‡∏ä‡πà‡∏ô "sounds/drum_low.mp3"
            leftRim:    "kongkang/thingman.wav", // ‡πÄ‡∏ä‡πà‡∏ô "sounds/rim_metal.mp3"
            rightCenter:"kongkang/thingwo.wav", // ‡πÄ‡∏ä‡πà‡∏ô "sounds/drum_high.mp3"
            rightRim:   "kongkang/jowo.wav"  // ‡πÄ‡∏ä‡πà‡∏ô "sounds/slap.mp3"
        };

        // --- 2. System Setup ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let masterGain;
        let limiter;
        let dest;
        let mediaRecorder;
        let chunks = [];
        let recordedBlob;
        let audioURL;
        let playbackAudio = new Audio();
        
        // ‡∏ï‡∏±‡∏ß‡πÄ‡∏Å‡πá‡∏ö Buffer ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏µ‡πà‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏£‡πá‡∏à‡πÅ‡∏•‡πâ‡∏ß
        const soundBuffers = {
            leftCenter: null,
            leftRim: null,
            rightCenter: null,
            rightRim: null
        };

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
                
                // Limiter ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏ï‡∏Å
                limiter = audioCtx.createDynamicsCompressor();
                limiter.threshold.value = -2;
                limiter.ratio.value = 12;
                limiter.attack.value = 0.002;

                masterGain = audioCtx.createGain();
                masterGain.gain.value = 1.0;

                masterGain.connect(limiter);
                limiter.connect(audioCtx.destination);

                dest = audioCtx.createMediaStreamDestination();
                masterGain.connect(dest);

                // ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÇ‡∏´‡∏•‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ó‡∏±‡∏ô‡∏ó‡∏µ‡∏ó‡∏µ‡πà User Interact ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡∏õ‡∏±‡∏ç‡∏´‡∏≤ Autoplay Policy)
                loadAllSounds();
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- 3. Loader & Decoder Logic ---

        async function loadAllSounds() {
            const status = document.getElementById('loadingStatus');
            status.textContent = "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏µ‡∏¢‡∏á...";
            
            const promises = Object.keys(soundUrls).map(key => loadSound(key, soundUrls[key]));
            await Promise.all(promises);
            
            status.textContent = "‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô!";
            setTimeout(() => status.style.opacity = 0, 2000);
        }

        async function loadSound(key, url) {
            if (!url) {
                // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ URL ‡πÉ‡∏´‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏±‡∏á‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏™‡∏≥‡∏£‡∏≠‡∏á (Fallback)
                soundBuffers[key] = createFallbackBuffer(key);
                return;
            }

            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                soundBuffers[key] = audioBuffer;
            } catch (e) {
                console.warn(`‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå ${key} ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡πÉ‡∏ä‡πâ‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á‡πÅ‡∏ó‡∏ô`, e);
                soundBuffers[key] = createFallbackBuffer(key);
            }
        }

        // ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏™‡∏≥‡∏£‡∏≠‡∏á‡∏Å‡∏£‡∏ì‡∏µ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå (‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πâ‡∏≤ Preview ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ)
        function createFallbackBuffer(type) {
            const sr = audioCtx.sampleRate;
            let duration = 0.5;
            if (type.includes('Rim')) duration = 0.3;
            
            const buffer = audioCtx.createBuffer(1, sr * duration, sr);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < buffer.length; i++) {
                const t = i / sr;
                // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÅ‡∏ö‡∏ö‡∏á‡πà‡∏≤‡∏¢‡πÜ ‡∏ï‡∏≤‡∏°‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó
                if (type === 'leftCenter') {
                    // Low Sine + Noise
                    data[i] = (Math.sin(2 * Math.PI * 60 * t) * Math.exp(-10 * t)) + (Math.random() * 0.1 * Math.exp(-20 * t));
                } else if (type === 'leftRim') {
                    // Metallic FM
                    data[i] = (Math.sin(2 * Math.PI * 800 * t + Math.sin(2 * Math.PI * 1200 * t)*5) * Math.exp(-15 * t));
                } else if (type === 'rightCenter') {
                    // High Sine
                    data[i] = (Math.sin(2 * Math.PI * 220 * t) * Math.exp(-15 * t)) + (Math.random() * 0.1 * Math.exp(-30 * t));
                } else if (type === 'rightRim') {
                    // Slap Noise
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-40 * t);
                }
            }
            return buffer;
        }

        // --- 4. Playback Engine with Envelopes ---

        function playBuffer(bufferName) {
            initAudio(); // Ensure context is ready
            
            const buffer = soundBuffers[bufferName];
            if (!buffer) return;

            const source = audioCtx.createBufferSource();
            source.buffer = buffer;

            // Envelope Gain (Fade In/Out)
            const envGain = audioCtx.createGain();
            
            // Wiring
            source.connect(envGain);
            envGain.connect(masterGain);

            const t = audioCtx.currentTime;
            const duration = buffer.duration;

            // --- Fade Logic (‡∏õ‡∏¥‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏≠‡∏≤‡∏Å‡∏≤‡∏®) ---
            // 1. ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ó‡∏µ‡πà 0 (‡πÄ‡∏á‡∏µ‡∏¢‡∏ö)
            envGain.gain.setValueAtTime(0, t);
            
            // 2. Fade In ‡πÄ‡∏£‡πá‡∏ß‡∏°‡∏≤‡∏Å (2ms) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏´‡∏±‡∏ß‡πÑ‡∏ü‡∏•‡πå
            envGain.gain.linearRampToValueAtTime(1.0, t + 0.002);

            // 3. Fade Out ‡∏ó‡∏µ‡πà‡∏õ‡∏•‡∏≤‡∏¢‡πÄ‡∏™‡∏µ‡∏¢‡∏á (10ms ‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏ö) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏ö‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡∏ã‡πà‡∏≤‡∏ó‡πâ‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå
            if (duration > 0.02) {
                envGain.gain.setValueAtTime(1.0, t + duration - 0.015);
                envGain.gain.linearRampToValueAtTime(0, t + duration);
            }

            source.start(t);
        }

        // --- 5. Interaction Logic ---
        
        function handleInteraction(event, padId, type) {
            if(event.type === 'touchstart') event.preventDefault();
            
            const pad = document.getElementById(padId);
            const rect = pad.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let touches = event.changedTouches ? Array.from(event.changedTouches) : [{clientX: event.clientX, clientY: event.clientY}];

            touches.forEach(touch => {
                if (event.changedTouches) {
                    const touchTarget = document.elementFromPoint(touch.clientX, touch.clientY);
                    if (touchTarget !== pad && !pad.contains(touchTarget)) return;
                }

                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                const maxRadius = rect.width / 2;
                let zoneFactor = Math.min(distance / maxRadius, 1.0);

                // ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÄ‡∏•‡πà‡∏ô‡∏ï‡∏≤‡∏°‡πÇ‡∏ã‡∏ô
                let soundKey = "";
                if (type === 'left') {
                    soundKey = zoneFactor < 0.6 ? 'leftCenter' : 'leftRim';
                } else {
                    soundKey = zoneFactor < 0.6 ? 'rightCenter' : 'rightRim';
                }

                playBuffer(soundKey);

                // Visual Feedback
                pad.classList.remove('active');
                void pad.offsetWidth; 
                pad.classList.add('active');
                setTimeout(() => pad.classList.remove('active'), 100);

                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                ripple.style.left = (touch.clientX - rect.left) + 'px';
                ripple.style.top = (touch.clientY - rect.top) + 'px';
                pad.appendChild(ripple);
                setTimeout(() => ripple.remove(), 400);
            });
        }

        const padLeft = document.getElementById('padLeft');
        const padRight = document.getElementById('padRight');
        const container = document.getElementById('drumContainer');

        padLeft.addEventListener('touchstart', (e) => handleInteraction(e, 'padLeft', 'left'), {passive: false});
        padRight.addEventListener('touchstart', (e) => handleInteraction(e, 'padRight', 'right'), {passive: false});
        padLeft.addEventListener('mousedown', (e) => handleInteraction(e, 'padLeft', 'left'));
        padRight.addEventListener('mousedown', (e) => handleInteraction(e, 'padRight', 'right'));

        // Keyboard Support
        document.addEventListener('keydown', (e) => {
            if (e.repeat) return;
            if (e.key === 'a') playBuffer('leftCenter');
            if (e.key === 'z') playBuffer('leftRim');
            if (e.key === 'd') playBuffer('rightCenter');
            if (e.key === 'c') playBuffer('rightRim');
        });

        // --- Controls Logic ---
        const btnNotes = document.getElementById('btnNotes');
        btnNotes.addEventListener('click', () => {
            container.classList.toggle('show-notes');
            btnNotes.textContent = container.classList.contains('show-notes') ? "üéµ ‡∏ã‡πà‡∏≠‡∏ô‡πÇ‡∏ô‡πâ‡∏ï" : "üéµ ‡πÇ‡∏ô‡πâ‡∏ï";
        });

        const btnRecord = document.getElementById('btnRecord');
        const btnStop = document.getElementById('btnStop');
        const btnPlay = document.getElementById('btnPlay');
        const btnDownload = document.getElementById('btnDownload');

        btnRecord.addEventListener('click', () => {
            initAudio();
            chunks = [];
            let options = { mimeType: 'audio/webm' };
            if (!MediaRecorder.isTypeSupported('audio/webm')) options = { mimeType: 'audio/mp4' };
            
            try {
                mediaRecorder = new MediaRecorder(dest.stream, options);
            } catch (err) {
                alert("Recording not supported fully");
                mediaRecorder = new MediaRecorder(dest.stream);
            }

            mediaRecorder.ondataavailable = (evt) => chunks.push(evt.data);
            mediaRecorder.onstop = () => {
                recordedBlob = new Blob(chunks, { type: 'audio/webm' });
                audioURL = URL.createObjectURL(recordedBlob);
                playbackAudio.src = audioURL;
                btnPlay.disabled = false;
                btnDownload.disabled = false;
            };

            mediaRecorder.start();
            btnRecord.classList.add('recording');
            btnRecord.disabled = true;
            btnStop.disabled = false;
            btnPlay.disabled = true;
            btnDownload.disabled = true;
        });

        btnStop.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                btnRecord.classList.remove('recording');
                btnRecord.disabled = false;
                btnStop.disabled = true;
            }
        });

        btnPlay.addEventListener('click', () => { if (audioURL) playbackAudio.play(); });

        btnDownload.addEventListener('click', () => {
            if (audioURL) {
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = audioURL;
                a.download = 'my-drum-solo.webm';
                document.body.appendChild(a);
                a.click();
                setTimeout(() => document.body.removeChild(a), 100);
            }
        });

    </script>
</body>
</html>
