<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>‡∏Å‡∏•‡∏≠‡∏á‡πÅ‡∏Ç‡∏Å‡πÄ‡∏™‡∏°‡∏∑‡∏≠‡∏ô‡∏à‡∏£‡∏¥‡∏á (Glong Khaek)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Sarabun:wght@400;700&display=swap');

        body {
            font-family: 'Sarabun', sans-serif;
            background-color: #2c1e12; /* Dark wood base */
            background-image: repeating-linear-gradient(45deg, #3d2b1f 25%, transparent 25%, transparent 75%, #3d2b1f 75%, #3d2b1f), repeating-linear-gradient(45deg, #3d2b1f 25%, #2c1e12 25%, #2c1e12 75%, #3d2b1f 75%, #3d2b1f);
            background-position: 0 0, 10px 10px;
            background-size: 20px 20px;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Disable browser handling of gestures */
            user-select: none;
            -webkit-user-select: none;
            height: 100vh;
            width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: space-between;
        }

        /* Drum Skin Texture */
        .drum-head {
            background: radial-gradient(circle at 30% 30%, #e6d5b8, #cfb893, #a68b64);
            box-shadow: 
                inset 0 0 20px rgba(0,0,0,0.6),
                0 10px 20px rgba(0,0,0,0.5),
                0 0 0 8px #5c4033, /* Wood rim */
                0 0 0 12px #2a1d12; /* Dark outer rim */
            position: relative;
            border-radius: 50%;
            transition: transform 0.05s, filter 0.05s;
            cursor: pointer;
            overflow: hidden;
            border: 2px solid rgba(255,255,255,0.1);
        }

        /* Interaction feedback */
        .drum-head:active, .drum-head.active {
            transform: scale(0.96);
            filter: brightness(0.9);
        }

        /* Center spot (Target) */
        .drum-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 35%;
            height: 35%;
            background: radial-gradient(circle, rgba(0,0,0,0.1), transparent 70%);
            border-radius: 50%;
            pointer-events: none; /* Let clicks pass through to parent logic */
            border: 1px dashed rgba(139, 69, 19, 0.3);
        }

        /* Rope Texture decoration */
        .rope {
            position: absolute;
            background: #d4a76a;
            width: 4px;
            height: 20px;
            z-index: -1;
            box-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }

        .control-panel {
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            border-top: 2px solid #8b4513;
            width: 100%;
            padding: 10px 5px;
            display: flex;
            justify-content: space-around;
            align-items: center;
            z-index: 10;
        }

        .btn {
            background: linear-gradient(to bottom, #8b5a2b, #5c3a1e);
            border: 1px solid #a67c52;
            color: #fff;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: bold;
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
            transition: all 0.2s;
            text-shadow: 1px 1px 2px black;
            min-width: 60px;
            text-align: center;
        }

        .btn:active {
            transform: translateY(2px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.4);
        }

        .btn.recording {
            background: linear-gradient(to bottom, #ff4444, #cc0000);
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 68, 68, 0); }
        }

        /* Start Overlay */
        #start-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
        }

        .tap-zone-label {
            position: absolute;
            font-size: 0.8rem;
            color: rgba(92, 64, 51, 0.7);
            font-weight: bold;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <!-- Header -->
    <div class="w-full text-center py-2 z-10 pointer-events-none">
        <h1 class="text-xl text-[#e6d5b8] font-bold drop-shadow-md tracking-wider">ü•Å ‡∏Å‡∏•‡∏≠‡∏á‡πÅ‡∏Ç‡∏Å (Virtual)</h1>
        <p class="text-xs text-[#a68b64]">‡πÅ‡∏ï‡∏∞‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á "‡∏ó‡∏∏‡πâ‡∏°" / ‡πÅ‡∏ï‡∏∞‡∏Ç‡∏≠‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏™‡∏µ‡∏¢‡∏á "‡πÅ‡∏´‡∏•‡∏°"</p>
    </div>

    <!-- Drum Area -->
    <div class="flex-grow flex flex-col justify-center items-center w-full max-w-lg relative gap-6 p-4">
        
        <!-- Drum 1: ‡∏ï‡∏±‡∏ß‡∏ú‡∏π‡πâ (Male) - Lower Pitch -->
        <div class="relative w-full aspect-square max-h-[35vh] flex justify-center items-center">
            <div id="drum-low" class="drum-head w-full h-full" data-drum="male">
                <div class="drum-center"></div>
                <span class="tap-zone-label top-4 left-1/2 transform -translate-x-1/2">‡∏Ç‡∏≠‡∏ö (‡∏ï‡∏¥‡∏á)</span>
                <span class="tap-zone-label top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-black/40">‡∏Å‡∏•‡∏≤‡∏á (‡πÇ‡∏à‡πä‡∏∞)</span>
            </div>
            <!-- Decorative Ropes -->
            <div class="rope" style="top: -15px; left: 20%; transform: rotate(-10deg);"></div>
            <div class="rope" style="top: -15px; right: 20%; transform: rotate(10deg);"></div>
            <div class="rope" style="bottom: -15px; left: 20%; transform: rotate(10deg);"></div>
            <div class="rope" style="bottom: -15px; right: 20%; transform: rotate(-10deg);"></div>
            <div class="absolute -bottom-6 text-[#e6d5b8] text-sm font-bold opacity-80">‡∏ï‡∏±‡∏ß‡∏ú‡∏π‡πâ (Male)</div>
        </div>

        <!-- Drum 2: ‡∏ï‡∏±‡∏ß‡πÄ‡∏°‡∏µ‡∏¢ (Female) - Higher Pitch -->
        <div class="relative w-full aspect-square max-h-[35vh] flex justify-center items-center">
            <div id="drum-high" class="drum-head w-full h-full" data-drum="female">
                <div class="drum-center"></div>
                <span class="tap-zone-label top-4 left-1/2 transform -translate-x-1/2">‡∏Ç‡∏≠‡∏ö (‡∏à‡πä‡∏∞)</span>
                <span class="tap-zone-label top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 text-black/40">‡∏Å‡∏•‡∏≤‡∏á (‡∏ï‡πâ‡∏°)</span>
            </div>
            <div class="absolute -bottom-6 text-[#e6d5b8] text-sm font-bold opacity-80">‡∏ï‡∏±‡∏ß‡πÄ‡∏°‡∏µ‡∏¢ (Female)</div>
        </div>

    </div>

    <!-- Controls -->
    <div class="control-panel pb-6 pt-3 safe-area-bottom">
        <button id="btn-record" class="btn" onclick="toggleRecording()">
            <span id="record-text">‚ö™ ‡∏≠‡∏±‡∏î‡πÄ‡∏™‡∏µ‡∏¢‡∏á</span>
        </button>
        <button id="btn-play" class="btn bg-gray-600" onclick="playRecording()" disabled>
            ‚ñ∂Ô∏è ‡πÄ‡∏•‡πà‡∏ô
        </button>
        <button id="btn-download" class="btn bg-gray-600" onclick="downloadRecording()" disabled>
            ‚¨áÔ∏è ‡πÇ‡∏´‡∏•‡∏î
        </button>
    </div>

    <!-- Start Overlay -->
    <div id="start-overlay" onclick="startApp()">
        <div class="text-6xl mb-4">ü•Å</div>
        <h2 class="text-2xl font-bold mb-2">‡∏Å‡∏•‡∏≠‡∏á‡πÅ‡∏Ç‡∏Å‡∏à‡∏≥‡∏•‡∏≠‡∏á</h2>
        <p class="mb-6 opacity-80">‡πÅ‡∏ï‡∏∞‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô (‡πÄ‡∏™‡∏µ‡∏¢‡∏á HD)</p>
        <div class="animate-bounce bg-[#e6d5b8] text-[#2c1e12] px-6 py-2 rounded-full font-bold shadow-lg cursor-pointer">
            ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏•‡∏¢
        </div>
    </div>

    <script>
        // --- Audio Engine Setup ---
        let audioCtx;
        let masterGain;
        let compressor;
        let reverbNode;
        let dest; 
        let mediaRecorder;
        let recordedChunks = [];
        let audioBlob;
        let audioUrl;
        
        function initAudio() {
            if (!audioCtx) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                
                // 1. Dynamics Compressor (To make it loud and punchy without clipping)
                compressor = audioCtx.createDynamicsCompressor();
                compressor.threshold.value = -20;
                compressor.knee.value = 30;
                compressor.ratio.value = 12;
                compressor.attack.value = 0.003;
                compressor.release.value = 0.25;

                // 2. Master Gain
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 1.0; // Max volume

                // 3. Reverb (Convolver) - Adds resonance
                reverbNode = audioCtx.createConvolver();
                reverbNode.buffer = createImpulseResponse(2.0, 2.0); // 2 seconds reverb

                // 4. Dry/Wet Mix for Reverb
                const dryNode = audioCtx.createGain();
                dryNode.gain.value = 0.7; // Original sound
                const wetNode = audioCtx.createGain();
                wetNode.gain.value = 0.3; // Reverb sound

                // Routing: Source -> [Dry + Wet(Reverb)] -> Compressor -> Destination
                // We connect Sources to 'masterGain' in playSound, so:
                masterGain.connect(dryNode);
                masterGain.connect(reverbNode);
                reverbNode.connect(wetNode);

                dryNode.connect(compressor);
                wetNode.connect(compressor);

                compressor.connect(audioCtx.destination);

                // Setup Recording Stream (From compressor output)
                dest = audioCtx.createMediaStreamDestination();
                compressor.connect(dest);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // Generate Artificial Reverb Impulse Response
        function createImpulseResponse(duration, decay) {
            const length = audioCtx.sampleRate * duration;
            const impulse = audioCtx.createBuffer(2, length, audioCtx.sampleRate);
            const left = impulse.getChannelData(0);
            const right = impulse.getChannelData(1);

            for (let i = 0; i < length; i++) {
                // Exponential decay noise
                const n = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                left[i] = n;
                right[i] = n;
            }
            return impulse;
        }

        // Generate Noise Buffer for "Snap" sound
        let noiseBuffer;
        function createNoiseBuffer() {
            if (!audioCtx) return;
            const bufferSize = audioCtx.sampleRate * 2; 
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            noiseBuffer = buffer;
        }

        function playSound(type, pitchMultiplier = 1) {
            if (!audioCtx) initAudio();
            if (!noiseBuffer) createNoiseBuffer();

            const t = audioCtx.currentTime;

            // Oscillator 1: The Main Body (Sine)
            const osc1 = audioCtx.createOscillator();
            const osc1Gain = audioCtx.createGain();
            osc1.connect(osc1Gain);
            osc1Gain.connect(masterGain);

            // Oscillator 2: The Harmonic Overtone (Triangle) - Adds richness
            const osc2 = audioCtx.createOscillator();
            const osc2Gain = audioCtx.createGain();
            osc2.connect(osc2Gain);
            osc2Gain.connect(masterGain);

            // Noise: The Slap/Hit
            const noise = audioCtx.createBufferSource();
            noise.buffer = noiseBuffer;
            const noiseFilter = audioCtx.createBiquadFilter();
            const noiseGain = audioCtx.createGain();
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(masterGain);

            if (type === 'center') {
                // "JO" or "TOM" - Deep, Resonant
                const baseFreq = 130 * pitchMultiplier;
                
                // Osc 1 (Body)
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(baseFreq, t);
                osc1.frequency.exponentialRampToValueAtTime(baseFreq * 0.6, t + 0.2); // Pitch drop tension
                osc1Gain.gain.setValueAtTime(0, t);
                osc1Gain.gain.linearRampToValueAtTime(1.5, t + 0.005); // Loud Attack
                osc1Gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5); // Sustain

                // Osc 2 (Harmonic)
                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(baseFreq * 2.02, t); // Slightly detuned harmonic
                osc2Gain.gain.setValueAtTime(0, t);
                osc2Gain.gain.linearRampToValueAtTime(0.3, t + 0.005);
                osc2Gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);

                // Noise (Impact) - Muffled
                noiseFilter.type = 'lowpass';
                noiseFilter.frequency.setValueAtTime(800, t);
                noiseGain.gain.setValueAtTime(0.5, t);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.05);

            } else if (type === 'rim') {
                // "TING" or "JA" - Sharp, High, Metallic
                const baseFreq = 250 * pitchMultiplier;

                // Osc 1 (Tone)
                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(baseFreq, t);
                osc1.frequency.exponentialRampToValueAtTime(baseFreq * 0.9, t + 0.1);
                osc1Gain.gain.setValueAtTime(0, t);
                osc1Gain.gain.linearRampToValueAtTime(0.8, t + 0.002);
                osc1Gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15); // Short decay

                // Osc 2 (Ring) - Very high harmonic
                osc2.type = 'square'; // Metallic texture
                osc2.frequency.setValueAtTime(baseFreq * 2.5, t);
                osc2Gain.gain.setValueAtTime(0, t);
                osc2Gain.gain.linearRampToValueAtTime(0.1, t + 0.002);
                osc2Gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);

                // Noise (Snap) - Bright and Loud
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.setValueAtTime(2000, t);
                noiseGain.gain.setValueAtTime(1.2, t); // Boost gain
                noiseGain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            }

            osc1.start(t);
            osc1.stop(t + 0.6);
            osc2.start(t);
            osc2.stop(t + 0.6);
            noise.start(t);
            noise.stop(t + 0.6);
        }

        // --- Interaction Logic ---
        
        function handleHit(element, e) {
            e.preventDefault(); // Prevent scrolling
            initAudio();

            // Get touch position relative to the element
            const rect = element.getBoundingClientRect();
            let clientX, clientY;

            if (e.changedTouches) {
                // Handle Multi-touch
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    processTouch(element, touch.clientX, touch.clientY, rect);
                }
            } else {
                // Mouse click
                processTouch(element, e.clientX, e.clientY, rect);
            }
        }

        function processTouch(element, x, y, rect) {
            // Visual Feedback
            element.classList.add('active');
            setTimeout(() => element.classList.remove('active'), 80); // Faster visual response

            // Calculate distance from center to determine Zone
            const centerX = rect.width / 2;
            const centerY = rect.height / 2;
            const touchX = x - rect.left;
            const touchY = y - rect.top;
            
            // Distance formula
            const dist = Math.sqrt(Math.pow(touchX - centerX, 2) + Math.pow(touchY - centerY, 2));
            const radius = rect.width / 2;
            const centerZoneRadius = radius * 0.45; // 45% is center zone

            const drumType = element.dataset.drum;
            const pitchMod = drumType === 'female' ? 1.35 : 1.0; // Adjusted pitch ratio

            if (dist < centerZoneRadius) {
                // Center Hit (Low/Deep)
                playSound('center', pitchMod);
            } else {
                // Rim Hit (High/Slap)
                playSound('rim', pitchMod);
            }
        }

        // Bind Events
        const drums = document.querySelectorAll('.drum-head');
        drums.forEach(drum => {
            drum.addEventListener('touchstart', (e) => handleHit(drum, e), { passive: false });
            drum.addEventListener('mousedown', (e) => handleHit(drum, e));
        });

        // --- Recording Logic ---

        let isRecording = false;

        function toggleRecording() {
            if (!isRecording) {
                startRecording();
            } else {
                stopRecording();
            }
        }

        function startRecording() {
            initAudio();
            recordedChunks = [];
            const options = MediaRecorder.isTypeSupported('audio/webm') ? { mimeType: 'audio/webm' } : {};
            
            try {
                mediaRecorder = new MediaRecorder(dest.stream, options);
            } catch (e) {
                alert("Browser recording not fully supported.");
                return;
            }

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) recordedChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                audioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                audioUrl = URL.createObjectURL(audioBlob);
                
                // Enable buttons
                document.getElementById('btn-play').disabled = false;
                document.getElementById('btn-play').classList.remove('bg-gray-600');
                document.getElementById('btn-play').classList.add('bg-green-600');
                
                document.getElementById('btn-download').disabled = false;
                document.getElementById('btn-download').classList.remove('bg-gray-600');
                document.getElementById('btn-download').classList.add('bg-blue-600');
            };

            mediaRecorder.start();
            isRecording = true;
            
            // UI Update
            const btn = document.getElementById('btn-record');
            btn.classList.add('recording');
            document.getElementById('record-text').innerText = "‚èπ ‡∏´‡∏¢‡∏∏‡∏î‡∏≠‡∏±‡∏î";
        }

        function stopRecording() {
            mediaRecorder.stop();
            isRecording = false;
            
            // UI Update
            const btn = document.getElementById('btn-record');
            btn.classList.remove('recording');
            document.getElementById('record-text').innerText = "üî¥ ‡∏≠‡∏±‡∏î‡πÉ‡∏´‡∏°‡πà";
        }

        function playRecording() {
            if (!audioUrl) return;
            const audio = new Audio(audioUrl);
            audio.play();
        }

        function downloadRecording() {
            if (!audioUrl) return;
            const a = document.createElement('a');
            a.href = audioUrl;
            a.download = `glong-khaek-${new Date().getTime()}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }

        // --- App Start ---
        function startApp() {
            initAudio();
            createNoiseBuffer(); // Pre-generate noise
            document.getElementById('start-overlay').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('start-overlay').style.display = 'none';
            }, 500);
        }

        // Prevent ContextMenu on hold
        window.oncontextmenu = function(event) {
            event.preventDefault();
            event.stopPropagation();
            return false;
        };

    </script>
</body>
</html>
