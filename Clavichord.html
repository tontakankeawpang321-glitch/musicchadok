<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Thai Mobile Clavichord</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* ป้องกันการเลือก text และการ Zoom บนมือถือ */
        body {
            touch-action: pan-x;
            user-select: none;
            -webkit-user-select: none;
            background-color: #2c1a0e; /* Dark Wood color */
            overflow: hidden;
            font-family: 'Sarabun', sans-serif;
        }

        /* ลายไม้ */
        .wood-texture {
            background: #5d4037;
            background-image: repeating-linear-gradient(45deg, rgba(255,255,255,0.05) 0px, rgba(255,255,255,0.05) 2px, transparent 2px, transparent 10px);
            box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
        }

        /* คีย์บอร์ด Wrapper - ปรับให้เต็มจอ ไม่ Scroll */
        .keyboard-container {
            width: 100%;
            height: 60vh;
            padding-top: 10px;
            background: #1a1a1a;
            box-shadow: inset 0 10px 20px rgba(0,0,0,0.5);
            position: relative;
            display: flex; /* ใช้ Flex เพื่อจัดเรียงคีย์ขาว */
            overflow: hidden; /* ซ่อนส่วนเกิน */
        }

        /* คีย์ขาว - ใช้ flex grow เพื่อให้แบ่งเท่ากัน */
        .key-white {
            flex: 1; /* ยืดเต็มพื้นที่เท่าๆ กัน */
            height: 100%;
            background: linear-gradient(to bottom, #fff 0%, #eee 90%, #ccc 100%);
            border: 1px solid #999;
            border-bottom: 6px solid #888;
            border-radius: 0 0 5px 5px;
            position: relative;
            z-index: 1;
            box-shadow: inset 0 -5px 10px rgba(0,0,0,0.1);
            transition: background 0.05s, transform 0.05s;
        }
        .key-white.active {
            background: #ddd;
            border-bottom: 2px solid #888;
            transform: translateY(4px);
        }

        /* คีย์ดำ - ใช้ absolute position คำนวณ % จาก JS */
        .key-black {
            position: absolute;
            top: 0;
            height: 60%;
            background: linear-gradient(to bottom, #333 0%, #000 100%);
            border: 1px solid #000;
            border-bottom: 4px solid #000;
            border-radius: 0 0 3px 3px;
            z-index: 10;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
            transition: background 0.05s, transform 0.05s;
            /* width และ left จะถูกกำหนดโดย JS */
        }
        .key-black.active {
            background: #222;
            border-bottom: 1px solid #000;
            transform: translateY(3px);
        }

        /* ป้ายชื่อโน้ต */
        .note-label {
            position: absolute;
            bottom: 15px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 0.8rem; /* ปรับขนาดตัวอักษรให้เล็กลงหน่อยเพื่อให้พอดี */
            color: #666;
            font-weight: bold;
            pointer-events: none;
        }
        .key-black .note-label {
            color: #aaa;
            bottom: 10px;
            font-size: 0.6rem;
        }

        /* ไฟสถานะอัดเสียง */
        .recording-dot {
            width: 12px;
            height: 12px;
            background-color: #555;
            border-radius: 50%;
            display: inline-block;
            margin-right: 5px;
        }
        .recording-dot.active {
            background-color: #ff3b30;
            box-shadow: 0 0 10px #ff3b30;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .controls-area {
            height: 40vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: #e2c7a6;
            text-shadow: 1px 1px 2px black;
        }

        .btn-custom {
            background: linear-gradient(to bottom, #8d6e63, #5d4037);
            border: 2px solid #3e2723;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            transition: all 0.1s;
        }
        .btn-custom:active {
            transform: translateY(2px);
            box-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="wood-texture h-screen w-screen overflow-hidden flex flex-col">

    <!-- ส่วนควบคุม -->
    <div class="controls-area p-4 space-y-4">
        <h1 class="text-3xl font-serif italic text-amber-200 tracking-wider">Clavichord</h1>
        
        <div class="bg-black/40 p-4 rounded-lg backdrop-blur-sm border border-white/10 w-full max-w-md flex flex-col gap-3">
            <!-- แถวปุ่มควบคุม -->
            <div class="flex justify-between items-center w-full">
                <div class="flex items-center gap-2">
                    <button id="recordBtn" class="btn-custom px-4 py-2 rounded-lg font-bold text-white flex items-center gap-2">
                        <span class="recording-dot" id="recDot"></span> อัดเสียง
                    </button>
                    <button id="stopRecBtn" class="btn-custom px-4 py-2 rounded-lg font-bold text-white hidden bg-red-800">
                        หยุด
                    </button>
                </div>
                <div class="text-sm text-amber-100/70">
                    Volume: <input type="range" id="volumeControl" min="0" max="1" step="0.1" value="0.7" class="accent-amber-500 w-20 align-middle">
                </div>
            </div>

            <!-- เครื่องเล่นเสียง -->
            <div id="audioPlayerContainer" class="hidden w-full mt-2">
                <audio id="audioPlayback" controls class="w-full h-8"></audio>
                <a id="downloadLink" class="text-xs text-amber-300 hover:text-white mt-1 block text-right">ดาวน์โหลดไฟล์เสียง</a>
            </div>
        </div>
        
        <p class="text-xs text-amber-100/50 mt-2">ขนาดพอดีหน้าจอ (C3-B4)</p>
    </div>

    <!-- ส่วนคีย์บอร์ด -->
    <div class="keyboard-container" id="keyboard">
        <!-- Keys will be generated by JS -->
    </div>

    <script>
        // --- 1. Audio Engine (Web Audio API) ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        let masterGain;
        let limiter;
        
        // สำหรับอัดเสียง
        let dest;
        let mediaRecorder;
        let audioChunks = [];

        // เก็บสถานะ Oscillator ที่กำลังเล่นเพื่อป้องกันเสียงค้าง
        const activeOscillators = {};

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new AudioContext();
                
                // Master Gain (Volume)
                masterGain = audioCtx.createGain();
                masterGain.gain.value = 0.7;

                // Limiter (ป้องกันเสียงแตกเมื่อกดหลายปุ่ม)
                limiter = audioCtx.createDynamicsCompressor();
                limiter.threshold.value = -10;
                limiter.knee.value = 40;
                limiter.ratio.value = 12;
                limiter.attack.value = 0;
                limiter.release.value = 0.25;

                masterGain.connect(limiter);
                limiter.connect(audioCtx.destination);
                
                // ตั้งค่าสำหรับอัดเสียง
                dest = audioCtx.createMediaStreamDestination();
                limiter.connect(dest);
            }
            if (audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }

        // --- 2. Clavichord Sound Synthesis ---
        // สูตร: Sawtooth wave (คมชัด) + Triangle wave (เนื้อเสียง) + Filter
        function playSound(noteFreq, keyId) {
            if (!audioCtx) initAudio();

            const now = audioCtx.currentTime;

            // 1. Oscillators
            const osc1 = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            
            // Clavichord มีความไม่สมบูรณ์เล็กน้อย (Detune)
            osc1.type = 'sawtooth';
            osc1.frequency.value = noteFreq;
            
            osc2.type = 'triangle';
            osc2.frequency.value = noteFreq;
            osc2.detune.value = 5; // Slight detune for richness

            // 2. Filter (Lowpass) จำลองไม้/สาย
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 2500; // Brightness
            filter.Q.value = 0.5;

            // 3. Envelope (ADSR)
            const gainNode = audioCtx.createGain();
            
            // Wiring
            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(masterGain);

            // Envelope Parameters (Clavichord is percussive but sustained if held)
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.5, now + 0.02); // Attack (Quick)
            gainNode.gain.exponentialRampToValueAtTime(0.3, now + 0.1); // Decay
            // Sustain level handled by holding the key, release handled in stopSound

            osc1.start(now);
            osc2.start(now);

            // Store active nodes to stop them later
            if (activeOscillators[keyId]) {
                stopSound(keyId); // Stop existing if re-triggered quickly
            }
            activeOscillators[keyId] = { osc1, osc2, gainNode, filter };
        }

        function stopSound(keyId) {
            if (!audioCtx || !activeOscillators[keyId]) return;

            const { osc1, osc2, gainNode } = activeOscillators[keyId];
            const now = audioCtx.currentTime;
            
            // Release phase (Clavichord sound stops almost immediately when key is lifted)
            // แต่ให้ Fade out นิดหน่อยกันเสียงตัด ("click")
            const releaseTime = 0.1; 
            gainNode.gain.cancelScheduledValues(now);
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.exponentialRampToValueAtTime(0.001, now + releaseTime);

            osc1.stop(now + releaseTime);
            osc2.stop(now + releaseTime);

            setTimeout(() => {
                // Garbage collection cleanup reference
                if(activeOscillators[keyId] === activeOscillators[keyId]) {
                    delete activeOscillators[keyId];
                }
            }, releaseTime * 1000 + 50);
        }

        // --- 3. Keyboard Generation & Logic (Fit Screen Version) ---
        const notes = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        // ปรับลด Octave ลงเพื่อให้พอดีหน้าจอ (2 Octaves)
        const startOctave = 3;
        const endOctave = 4;
        const keyboardEl = document.getElementById('keyboard');

        function getFrequency(note, octave) {
            const noteIndex = notes.indexOf(note);
            let semitonesFromA4 = (noteIndex - 9) + ((octave - 4) * 12);
            return 440 * Math.pow(2, semitonesFromA4 / 12);
        }

        function renderKeyboard() {
            // 1. Count Total White Keys first to calculate percentages
            let totalWhiteKeys = 0;
            for (let oct = startOctave; oct <= endOctave; oct++) {
                notes.forEach(note => {
                    if (!note.includes('#')) totalWhiteKeys++;
                });
            }

            const whiteKeyWidthPercent = 100 / totalWhiteKeys;
            const blackKeyWidthPercent = whiteKeyWidthPercent * 0.65; // Black key is ~65% of white key width
            
            let whiteKeyIndex = 0; // Track current white key position

            for (let oct = startOctave; oct <= endOctave; oct++) {
                notes.forEach((note) => {
                    const isSharp = note.includes('#');
                    const freq = getFrequency(note, oct);
                    const keyId = `key-${note}-${oct}`;
                    const label = oct === startOctave || note === 'C' ? note + oct : note; 

                    if (!isSharp) {
                        // --- White Key ---
                        const key = document.createElement('div');
                        key.className = 'key-white';
                        key.id = keyId;
                        key.dataset.freq = freq;
                        key.innerHTML = `<span class="note-label">${note}${oct}</span>`;
                        // Width handled by flex: 1 in CSS
                        keyboardEl.appendChild(key);
                        addInteraction(key, freq, keyId);
                        
                        whiteKeyIndex++; // Move forward
                    } else {
                        // --- Black Key ---
                        const key = document.createElement('div');
                        key.className = 'key-black';
                        key.id = keyId;
                        key.dataset.freq = freq;
                        
                        // Calculate Left Position
                        // The black key sits between the previous white key (index-1) and current white key (index)
                        // Actually, C# is after C. So if C is index 1 (visually), C# is on the right edge of C.
                        // Logic: center of C# should align with the line between C and D.
                        // Current 'whiteKeyIndex' has already been incremented for the previous natural note (e.g., C).
                        // So the boundary is at (whiteKeyIndex * whiteKeyWidthPercent).
                        // Left = Boundary - (BlackWidth / 2)
                        
                        const leftPos = (whiteKeyIndex * whiteKeyWidthPercent) - (blackKeyWidthPercent / 2);
                        
                        key.style.width = `${blackKeyWidthPercent}%`;
                        key.style.left = `${leftPos}%`;
                        
                        // key.innerHTML = `<span class="note-label">${note}</span>`;
                        keyboardEl.appendChild(key);
                        addInteraction(key, freq, keyId);
                    }
                });
            }
        }

        // --- 4. Input Handling (Touch & Mouse) ---
        function addInteraction(element, freq, keyId) {
            const start = (e) => {
                e.preventDefault(); // Prevent scroll/zoom on key press
                if(!element.classList.contains('active')) {
                    element.classList.add('active');
                    playSound(freq, keyId);
                }
            };

            const end = (e) => {
                e.preventDefault();
                element.classList.remove('active');
                stopSound(keyId);
            };

            // Touch Events
            element.addEventListener('touchstart', start, { passive: false });
            element.addEventListener('touchend', end);
            element.addEventListener('touchcancel', end);

            // Mouse Events
            element.addEventListener('mousedown', start);
            element.addEventListener('mouseup', end);
            element.addEventListener('mouseleave', end);
        }

        // --- 5. Recording System ---
        const recordBtn = document.getElementById('recordBtn');
        const stopRecBtn = document.getElementById('stopRecBtn');
        const recDot = document.getElementById('recDot');
        const audioPlayerContainer = document.getElementById('audioPlayerContainer');
        const audioPlayback = document.getElementById('audioPlayback');
        const downloadLink = document.getElementById('downloadLink');

        recordBtn.addEventListener('click', () => {
            initAudio(); // Ensure context is ready
            audioChunks = [];
            
            // Check browser support
            const mimeType = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : 'audio/mp4';

            try {
                mediaRecorder = new MediaRecorder(dest.stream, { mimeType: mimeType });
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: mimeType });
                    const audioUrl = URL.createObjectURL(audioBlob);
                    audioPlayback.src = audioUrl;
                    downloadLink.href = audioUrl;
                    downloadLink.download = `clavichord-recording-${new Date().getTime()}.webm`;
                    audioPlayerContainer.classList.remove('hidden');
                };

                mediaRecorder.start();
                
                // UI Update
                recordBtn.classList.add('hidden');
                stopRecBtn.classList.remove('hidden');
                recDot.classList.add('active');
                audioPlayerContainer.classList.add('hidden');

            } catch (err) {
                alert("Browser recording not supported or failed: " + err);
            }
        });

        stopRecBtn.addEventListener('click', () => {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();
                // UI Update
                stopRecBtn.classList.add('hidden');
                recordBtn.classList.remove('hidden');
                recDot.classList.remove('active');
            }
        });

        // Volume Control
        document.getElementById('volumeControl').addEventListener('input', (e) => {
            if (masterGain) {
                masterGain.gain.value = parseFloat(e.target.value);
            }
        });

        // Initialize
        renderKeyboard();

        // Global unlock audio context on first touch anywhere
        document.body.addEventListener('touchstart', function() {
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }, { once: true });

        document.body.addEventListener('click', function() {
            if (audioCtx && audioCtx.state === 'suspended') {
                audioCtx.resume();
            }
        }, { once: true });

    </script>
</body>
</html>